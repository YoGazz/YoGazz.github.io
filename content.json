{"meta":{"title":"佑珈の博客","subtitle":"记录生活中的点点滴滴","description":"我自是年少，韶华倾覆","author":"佑珈","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-27T02:52:28.441Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2024-06-03T10:12:52.479Z","updated":"2023-05-26T16:47:29.353Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-26T16:47:29.354Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-27T03:22:39.413Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"Python Django Vue 测试平台 接口自动化 UI自动化 性能测试"},{"title":"友情链接","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-26T16:47:29.354Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-06-03T10:12:52.482Z","updated":"2023-05-26T16:47:29.354Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-06-03T10:12:52.482Z","updated":"2023-05-26T16:47:29.355Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据迁移测试","slug":"数据迁移测试","date":"2024-11-22T02:27:23.000Z","updated":"2024-11-22T04:10:05.535Z","comments":true,"path":"2024/11/22/数据迁移测试/","link":"","permalink":"http://example.com/2024/11/22/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/","excerpt":"数据迁移主要是在新老系统切换的时候，主要是以下新、两种 将老系统中的数据全部迁移到新系统，业务上只使用新系统，不再使用老系统 老系统的某些功能暂时无法实现，但是要在业务中使用新系统，这时候新老系统都需要使用，老系统产生的数据需要增量同步到新系统的数据库中","text":"数据迁移主要是在新老系统切换的时候，主要是以下新、两种 将老系统中的数据全部迁移到新系统，业务上只使用新系统，不再使用老系统 老系统的某些功能暂时无法实现，但是要在业务中使用新系统，这时候新老系统都需要使用，老系统产生的数据需要增量同步到新系统的数据库中 一、数据迁移的风险1、需要确认数据规模，这次迁移的数据量，线上数据库那么如果按照顺序迁移，则可能花费几个月甚至几年的时间。 2、迁移过程中服务是否需要停止， 因为不能在迁移过程中中断或者停止所有或部分服务，那么在这个迁移过程中必须要保证服务100%处于可用状态。 3、保证数据的，正确性，一致性，可用性，在数据迁移过程中，必须确保每项服务获取到的数据都是正确无误 二、数据迁移前的准备工作在进行数据迁移前需要和开发、产品、运维等确认好数据的迁移范围 在进行测试之前，需要对核心的测试点做重点的梳理，其中主要包括本次迁移涉及到的后端接口、对应的数据库表以及数据迁移的接口 涉及到了4个库7张表，关系复杂，需要验证的数据内容较多，针对性的列出了对应场景和表表直接关系，以及一些细节关注点 三、迁移数据的方法1、直接复制表 将原有系统数据库中的表直接复制到新系统的数据库中； 2、拆表&amp;合表 拆表：将原有系统数据库中的表数据拆分到新系统数据库中的几张表中； 合表：将原有系统数据库中的表字段合并到新系统数据库中的一张表中； PS：需要确认清楚，哪些表分拆迁移，哪些表合并迁移，迁移的数据字段、条数等！ 1.3：数据迁移接口及数据校验接口 四、数据迁移测试1、数据量一致性测试 要做到新老系统无缝切换，就必须保证数据的正确性和一致性，首要条件就是迁移的数据量是保持一致的，否则无法进行其他测试。 方法：①、可以通过文本统计工具或者数据库连接工具将迁移前的数据库表名、字段、数量等进行统计，然后将迁移后的新数据库表名、字段、数量等进行统计，然后进行比较。 ②、通过MD5生成工具，对新老数据文本进行MD5值比对测试，如果一致则表示数据量一致，如果不一致，则表明迁移后的数据有部分存在问题。 2、数据库表结构变化测试 这种测试分2种情况：一种是新老数据库表结构完全不存在关系，新数据库表的字段都是给定的默认值；还有一种是新数据库表字段是由原有系统数据库表字段转换而来。 方法：针对第一种情况，因为新增的字段都是给定的默认值，所以只需要根据开发提供的填写规则，检查该字段的所有值是否满足填写规则。 针对第二种情况，可以通过编写自动化测试脚本或者人工抽样或者切片方式进行，具体的抽样选择根据数据量等具体情况选择合适的比例即可。 五、业务逻辑测试完成上面的数据迁移测试后，需要在新的系统中进行回归测试，以确保迁移过来的数据是100%可用的。 回归测试前需要和业务、开发确认哪些业务模块涉及了哪些表，然后根据具体情况，尽可能的提高测试用例覆盖率，做一次全系统的功能回归测试（可以考虑自动化测试来替代一部分手工测试）。","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"数据迁移","slug":"数据迁移","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"}]},{"title":"Httprunner源码解读(3)client.py","slug":"Httprunner源码解读-3-client-py","date":"2023-06-12T02:38:38.000Z","updated":"2024-11-22T04:11:09.161Z","comments":true,"path":"2023/06/12/Httprunner源码解读-3-client-py/","link":"","permalink":"http://example.com/2023/06/12/Httprunner%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-3-client-py/","excerpt":"client.py的代码结构这个模块中定义了2个类和1个方法 ApiResponse类1234567891011class ApiResponse(Response): &quot;&quot;&quot; 继承Response 类，重写了raise_for_status方法，用于检查响应是否包含错误信息，并在响应中包含错误信息时抛出相应的异常 raise_for_status 方法首先检查响应对象是否包含 error 属性，并且该属性的值不为 None。如果 error 属性存在且不为 None，则抛出 error 异常。 否则，调用父类 Response 的 raise_for_status 方法，检查响应的状态码是否为 4xx 或 5xx，如果是，则抛出相应的异常。 &quot;&quot;&quot; def raise_for_status(self): if hasattr(self, &quot;error&quot;) and self.error: raise self.error Response.raise_for_status(self)","text":"client.py的代码结构这个模块中定义了2个类和1个方法 ApiResponse类1234567891011class ApiResponse(Response): &quot;&quot;&quot; 继承Response 类，重写了raise_for_status方法，用于检查响应是否包含错误信息，并在响应中包含错误信息时抛出相应的异常 raise_for_status 方法首先检查响应对象是否包含 error 属性，并且该属性的值不为 None。如果 error 属性存在且不为 None，则抛出 error 异常。 否则，调用父类 Response 的 raise_for_status 方法，检查响应的状态码是否为 4xx 或 5xx，如果是，则抛出相应的异常。 &quot;&quot;&quot; def raise_for_status(self): if hasattr(self, &quot;error&quot;) and self.error: raise self.error Response.raise_for_status(self) get_req_resp_record方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283def get_req_resp_record(resp_obj: Response) -&gt; ReqRespData: &quot;&quot;&quot;get request and response info from Response() object.&quot;&quot;&quot;# 定义了一个打印日志的函数，将打印的日志解析为标准的json格式 def log_print(req_or_resp, r_type): msg = f&quot;\\n================== &#123;r_type&#125; details ==================\\n&quot; for key, value in req_or_resp.dict().items(): if isinstance(value, dict) or isinstance(value, list): value = json.dumps(value, indent=4, ensure_ascii=False) msg += &quot;&#123;:&lt;8&#125; : &#123;&#125;\\n&quot;.format(key, value) logger.debug(msg) # record actual request info # 是先获取request_headers、request_cookies、request_body，然后将获取到的信息放入RequestData模型中，最后打印请求的信息 request_headers = dict(resp_obj.request.headers) request_cookies = resp_obj.request._cookies.get_dict() request_body = resp_obj.request.body if request_body is not None: try: request_body = json.loads(request_body) except json.JSONDecodeError: # str: a=1&amp;b=2 pass except UnicodeDecodeError: # bytes/bytearray: request body in protobuf pass except TypeError: # neither str nor bytes/bytearray, e.g. &lt;MultipartEncoder&gt; pass request_content_type = lower_dict_keys(request_headers).get(&quot;content-type&quot;) if request_content_type and &quot;multipart/form-data&quot; in request_content_type: # upload file type request_body = &quot;upload file stream (OMITTED)&quot; request_data = RequestData( method=resp_obj.request.method, url=resp_obj.request.url, headers=request_headers, cookies=request_cookies, body=request_body, ) # log request details in debug mode log_print(request_data, &quot;request&quot;) # record response info # 获取resp_headers、content_type、response_body，最后将这些数据都放入ResponseData模型类中，最后打印响应日志 resp_headers = dict(resp_obj.headers) lower_resp_headers = lower_dict_keys(resp_headers) content_type = lower_resp_headers.get(&quot;content-type&quot;, &quot;&quot;) if &quot;image&quot; in content_type: # response is image type, record bytes content only response_body = resp_obj.content else: try: # try to record json data response_body = resp_obj.json() except ValueError: # only record at most 512 text charactors resp_text = resp_obj.text response_body = omit_long_data(resp_text) response_data = ResponseData( status_code=resp_obj.status_code, cookies=resp_obj.cookies or &#123;&#125;, encoding=resp_obj.encoding, headers=resp_headers, content_type=content_type, body=response_body, ) # log response details in debug mode log_print(response_data, &quot;response&quot;) # 请求信息和响应信息全部放入ReqRespData模型中，最后get_req_resp_record函数返回的内容就是ReqRespData模型req_resp_data = ReqRespData(request=request_data, response=response_data) return req_resp_data HttpSession类HttpSession 是一个用于执行 HTTP 请求的类，它继承自 requests.Session 类，并扩展了一些功能。HttpSession 类的主要作用是在发送 HTTP 请求时记录请求和响应的信息，以便后续进行统计和分析 123def __init__(self): super(HttpSession, self).__init__() self.data = SessionData() 初始化方法，定义了data属性的默认值为SessionData模型，该模型包含了req_resps: List[ReqRespData] &#x3D; []请求响应内容 1234567def update_last_req_resp_record(self, resp_obj): &quot;&quot;&quot; update request and response info from Response() object. &quot;&quot;&quot; # TODO: fix self.data.req_resps.pop() self.data.req_resps.append(get_req_resp_record(resp_obj)) update_last_req_resp_record 方法用于更新最后一次请求和响应的信息，该方法会从 Response 对象中提取请求和响应的信息，并更新到 SessionData 对象中 123456789101112131415def _send_request_safe_mode(self, method, url, **kwargs): &quot;&quot;&quot; Send a HTTP request, and catch any exception that might occur due to connection problems. Safe mode has been removed from requests 1.x. &quot;&quot;&quot; try: return requests.Session.request(self, method, url, **kwargs) except (MissingSchema, InvalidSchema, InvalidURL): raise except RequestException as ex: resp = ApiResponse() resp.error = ex resp.status_code = 0 # with this status_code, content returns None resp.request = Request(method, url).prepare() return resp _send_request_safe_mode 方法用于发送 HTTP 请求，并捕获可能发生的连接问题异常。如果发送请求时发生异常，则返回一个 ApiResponse 对象，该对象包含了异常信息和请求对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293def request(self, method, url, name=None, **kwargs): &quot;&quot;&quot; Constructs and sends a :py:class:`requests.Request`. Returns :py:class:`requests.Response` object. :param method: method for the new :class:`Request` object. :param url: URL for the new :class:`Request` object. :param name: (optional) Placeholder, make compatible with Locust&#x27;s HttpSession :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`. :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`. :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects`` for multipart encoding upload. :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth. :param timeout: (optional) How long to wait for the server to send data before giving up, as a float, or \\ a (`connect timeout, read timeout &lt;user/advanced.html#timeouts&gt;`_) tuple. :type timeout: float or tuple :param allow_redirects: (optional) Set to True by default. :type allow_redirects: bool :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy. :param stream: (optional) whether to immediately download the response content. Defaults to ``False``. :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided. :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair. &quot;&quot;&quot; self.data = SessionData() # timeout default to 120 seconds kwargs.setdefault(&quot;timeout&quot;, 120) # set stream to True, in order to get client/server IP/Port kwargs[&quot;stream&quot;] = True start_timestamp = time.time() response = self._send_request_safe_mode(method, url, **kwargs) response_time_ms = round((time.time() - start_timestamp) * 1000, 2) try: client_ip, client_port = response.raw._connection.sock.getsockname() self.data.address.client_ip = client_ip self.data.address.client_port = client_port logger.debug(f&quot;client IP: &#123;client_ip&#125;, Port: &#123;client_port&#125;&quot;) except Exception: pass try: server_ip, server_port = response.raw._connection.sock.getpeername() self.data.address.server_ip = server_ip self.data.address.server_port = server_port logger.debug(f&quot;server IP: &#123;server_ip&#125;, Port: &#123;server_port&#125;&quot;) except Exception: pass # get length of the response content content_size = int(dict(response.headers).get(&quot;content-length&quot;) or 0) # record the consumed time self.data.stat.response_time_ms = response_time_ms self.data.stat.elapsed_ms = response.elapsed.microseconds / 1000.0 self.data.stat.content_size = content_size # record request and response histories, include 30X redirection response_list = response.history + [response] self.data.req_resps = [ get_req_resp_record(resp_obj) for resp_obj in response_list ] try: response.raise_for_status() except RequestException as ex: logger.error(f&quot;&#123;str(ex)&#125;&quot;) else: logger.info( f&quot;status_code: &#123;response.status_code&#125;, &quot; f&quot;response_time(ms): &#123;response_time_ms&#125; ms, &quot; f&quot;response_length: &#123;content_size&#125; bytes&quot; ) return response 最重要的 request 方法。request 方法用于构造并发送一个 HTTP 请求，并返回一个 requests.Response 对象。在发送请求之前，request 方法会先清空之前的请求和响应信息，然后设置一些默认参数，如超时时间、是否允许重定向等。接着，request 方法会调用 _send_request_safe_mode 方法发送请求，并记录请求和响应的信息。最后，request 方法会检查响应的状态码是否为 4xx 或 5xx，如果是，则抛出相应的异常。主要做了以下事情 设置了超时时间120s 计算整个请求花费了多少时间 定义了客户端ip地址和端口号、服务端ip地址和端口号 计算了响应体的内容大小 记录了消耗时间 记录了request和response记录，包括重定向记录","categories":[{"name":"Httprunner","slug":"Httprunner","permalink":"http://example.com/categories/Httprunner/"}],"tags":[{"name":"httprunner","slug":"httprunner","permalink":"http://example.com/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Httprunner源码解读(2)models.py","slug":"Httprunner源码解读-2-models-py","date":"2023-06-11T10:18:24.000Z","updated":"2024-11-22T04:11:03.405Z","comments":true,"path":"2023/06/11/Httprunner源码解读-2-models-py/","link":"","permalink":"http://example.com/2023/06/11/Httprunner%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-2-models-py/","excerpt":"models.py的代码结构这个模块中定义了12个属性和29个模型类文件主要包含了一系列用于描述测试配置、请求和响应的数据模型类。这些数据模型通常继承自 Pydantic’s BaseModel 类，它们用于实现类型检查、数据验证以及序列化和反序列化等功能。","text":"models.py的代码结构这个模块中定义了12个属性和29个模型类文件主要包含了一系列用于描述测试配置、请求和响应的数据模型类。这些数据模型通常继承自 Pydantic’s BaseModel 类，它们用于实现类型检查、数据验证以及序列化和反序列化等功能。 models.py 中的数据模型提供了以下几个方面的功能： 定义测试用例的数据结构：通过创建数据模型来表示测试用例的各个组成部分，如配置、请求、响应和变量等。 类型检查和数据验证：利用 Pydantic 提供的类型检查和验证机制，确保从 YAML&#x2F;JSON 测试用例文件中加载的数据符合预期格式和约束。 序列化与反序列化：Pydantic 数据模型可以轻松地将 Python 对象转换为 JSON 格式，或者将 JSON 数据反序列化为 Python 对象。 总的来说，models.py 文件对 HttpRunner 的整个测试流程提供了结构支持，确保了测试用例以一种结构化、可靠且易于解析的方式进行编写和执行。通过使用这些数据模型，HttpRunner 可以更容易地处理、验证和操作来自测试用例文件的数据。 BaseModel 是一个pydantic的基础类，用于数据验证和序列化。它的作用主要包括： 类型检查：确保输入数据符合预期类型。 数据验证：根据模型中定义的限制条件对输入数据进行验证。 默认值设置：自动为缺失字段提供默认值。 序列化与反序列化：将 Python 对象转换为 JSON 格式，以及从 JSON 转换回 Python 对象。 通过继承 BaseModel 并定义字段，用户可以轻松构建自己的数据模型。这有助于减少代码错误、提高数据质量和简化数据处理流程。 属性源码分析123456789101112131415161718192021222324import osfrom enum import Enumfrom typing import Any, Callable, Dict, List, Text, Unionfrom pydantic import BaseModel, Field, HttpUrl&quot;&quot;&quot;Text =&gt; str / 文本List =&gt; list / 列表Dict =&gt; dict / 字典&quot;&quot;&quot;Name = TextUrl = TextBaseUrl = Union[HttpUrl, Text]VariablesMapping = Dict[Text, Any]FunctionsMapping = Dict[Text, Callable]Headers = Dict[Text, Text]Cookies = Dict[Text, Text]Verify = boolHooks = List[Union[Text, Dict[Text, Text]]]Export = List[Text]Validators = List[Dict]Env = Dict[Text, Any] 用到了typing和pydantic模块，定义了这些属性的类型 模型类源码分析MethodEnum1234567891011class MethodEnum(Text, Enum): &quot;&quot;&quot; 内置枚举类，常用请求的方式 &quot;&quot;&quot; GET = &quot;GET&quot; POST = &quot;POST&quot; PUT = &quot;PUT&quot; DELETE = &quot;DELETE&quot; HEAD = &quot;HEAD&quot; OPTIONS = &quot;OPTIONS&quot; PATCH = &quot;PATCH&quot; ProtoType12345678class ProtoType(Enum): &quot;&quot;&quot; 内置枚举类，请求数据类型 &quot;&quot;&quot; Binary = 1 CyBinary = 2 Compact = 3 Json = 4 TransType12345678class ProtoType(Enum): &quot;&quot;&quot; 内置枚举类，请求数据类型 &quot;&quot;&quot; Binary = 1 CyBinary = 2 Compact = 3 Json = 4 TransType12345678class TransType(Enum): &quot;&quot;&quot; 内置枚举类，它定义了 thrift 协议中数据传输类型 &quot;&quot;&quot; Buffered = 1 CyBuffered = 2 Framed = 3 CyFramed = 4 TConfigThrift123456789101112131415161718class TConfigThrift(BaseModel): &quot;&quot;&quot; 内置枚举类, 定义TConfigThrift 的数据模型 &quot;&quot;&quot; psm: Text = None env: Text = None cluster: Text = None target: Text = None include_dirs: List[Text] = None thrift_client: Any = None timeout: int = 10 idl_path: Text = None method: Text = None ip: Text = &quot;127.0.0.1&quot; port: int = 9000 service_name: Text = None proto_type: ProtoType = ProtoType.Binary trans_type: TransType = TransType.Buffered TConfigDB12345678910class TConfigDB(BaseModel): &quot;&quot;&quot; 内置枚举类, 定义用于存储与数据库相关的配置信息 &quot;&quot;&quot; psm: Text = None user: Text = None password: Text = None ip: Text = None port: int = 3306 database: Text = None TransportEnum1234567class TransportEnum(Text, Enum): &quot;&quot;&quot; 内置枚举类,继承自 Text 和 Enum。它定义了两个枚举值：BUFFERED 和 FRAMED，分别表示缓冲传输和帧传输。枚举值的类型是 Text， 因此它们可以是任何字符串。枚举类的作用是为 HttpRunner 提供传输类型的选择 &quot;&quot;&quot; BUFFERED = &quot;buffered&quot; FRAMED = &quot;framed&quot; TThriftRequest1234567891011121314151617181920212223class TThriftRequest(BaseModel): &quot;&quot;&quot; rpc request model 内置枚举类，它继承自 BaseModel。它定义了一些属性，用于表示 Thrift 请求的相关信息，包括方法名、参数、Thrift 客户端、IDL 文件路径、 超时时间、传输类型、目标地址、环境、集群、PSM、服务名、IP、端口、协议类型和传输类型等。这些属性都有默认值，可以通过实例化对象来设置它们的值 &quot;&quot;&quot; method: Text = &quot;&quot; params: Dict = &#123;&#125; thrift_client: Any = None idl_path: Text = &quot;&quot; # idl local path timeout: int = 10 # sec transport: TransportEnum = TransportEnum.BUFFERED include_dirs: List[Union[Text, None]] = [] # param of thriftpy2.load target: Text = &quot;&quot; # tcp://&#123;ip&#125;:&#123;port&#125; or sd://psm?cluster=xx&amp;env=xx env: Text = &quot;prod&quot; cluster: Text = &quot;default&quot; psm: Text = &quot;&quot; service_name: Text = None ip: Text = None port: int = None proto_type: ProtoType = None trans_type: TransType = None SqlMethodEnum1234567891011class SqlMethodEnum(Text, Enum): &quot;&quot;&quot; 内置枚举类，它继承自 Text 和 Enum。它定义了一些枚举值，用于表示 SQL 操作的类型，包括 FETCHONE、FETCHMANY、FETCHALL、INSERT、UPDATE 和 DELETE。 这些枚举值可以通过实例化对象来访问，以执行相应的 SQL 操作 &quot;&quot;&quot; FETCHONE = &quot;FETCHONE&quot; FETCHMANY = &quot;FETCHMANY&quot; FETCHALL = &quot;FETCHALL&quot; INSERT = &quot;INSERT&quot; UPDATE = &quot;UPDATE&quot; DELETE = &quot;DELETE&quot; TSqlRequest123456789101112class TSqlRequest(BaseModel): &quot;&quot;&quot; sql request model 内置枚举类, 它继承自 BaseModel。它定义了一些属性，用于表示 SQL 请求的相关信息，包括数据库配置、SQL 操作类型、SQL 语句和结果集大小等。其中，db_config 属性表示数据库配置信息， 它是一个 TConfigDB 类型的对象，包括 PSM、用户名、密码、IP、端口和数据库名等。method 属性表示 SQL 操作类型，它是一个 SqlMethodEnum 类型的枚举值，包括 FETCHONE、FETCHMANY、FETCHALL、 INSERT、UPDATE 和 DELETE。sql 属性表示 SQL 语句，size 属性表示结果集大小，用于限制 SQL 查询结果的数量。 &quot;&quot;&quot; db_config: TConfigDB = TConfigDB() method: SqlMethodEnum = None sql: Text = None size: int = 0 # limit nums of sql result TConfig1234567891011121314151617181920212223242526class TConfig(BaseModel): &quot;&quot;&quot; 内置枚举类 它定义了一些属性，用于表示 HttpRunner 的配置信息，包括名称、验证、基础 URL、变量、参数、导出变量、路径、Thrift 配置和数据库配置等。 其中，name 属性表示配置对象的名称， verify 属性表示是否验证 SSL 证书， base_url 属性表示基础 URL， variables 属性表示变量，可以是一个字典或者是一个字符串，字符串表示变量的 Python 代码， parameters 属性表示参数，可以是一个字典或者是一个字符串，字符串表示参数的 Python 代码，export 属性表示导出变量的名称列表， path 属性表示配置文件的路径， thrift 属性表示 Thrift 配置信息，是一个 TConfigThrift 类型的对象， db 属性表示数据库配置信息，是一个 TConfigDB 类型的对象。 &quot;&quot;&quot; name: Name verify: Verify = False base_url: BaseUrl = &quot;&quot; # Text: prepare variables in debugtalk.py, $&#123;gen_variables()&#125; variables: Union[VariablesMapping, Text] = &#123;&#125; parameters: Union[VariablesMapping, Text] = &#123;&#125; # setup_hooks: Hooks = [] # teardown_hooks: Hooks = [] export: Export = [] path: Text = None # configs for other protocols thrift: TConfigThrift = None db: TConfigDB = TConfigDB() TRequest12345678910111213141516171819202122232425262728class TRequest(BaseModel): &quot;&quot;&quot; requests.Request model 内置枚举类 它继承自 BaseModel。它定义了一些属性，用于表示 HTTP 请求的相关信息，包括请求方法、URL、查询参数、请求头、请求体、数据、超时时间、重定向、SSL 验证和上传文件等。 method 属性表示请求方法，它是一个 MethodEnum 类型的枚举值，包括 GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH 和 TRACE。 url 属性表示请求的 URL， params 属性表示查询参数，headers 属性表示请求头， req_json 属性表示请求体，可以是一个字典、列表或者字符串，字符串表示请求体的 JSON 格式的字符串， data 属性表示请求数据，可以是一个字典或者字符串，字符串表示请求数据的 Python 代码， cookies 属性表示请求的 cookies， timeout 属性表示超时时间， allow_redirects 属性表示是否允许重定向， verify 属性表示是否验证 SSL 证书， upload 属性表示上传文件的信息，是一个字典，包括文件名、文件路径和文件类型等。 &quot;&quot;&quot; method: MethodEnum url: Url params: Dict[Text, Text] = &#123;&#125; headers: Headers = &#123;&#125; req_json: Union[Dict, List, Text] = Field(None, alias=&quot;json&quot;) data: Union[Text, Dict[Text, Any]] = None cookies: Cookies = &#123;&#125; timeout: float = 120 allow_redirects: bool = True verify: Verify = False upload: Dict = &#123;&#125; # used for upload files TStep1234567891011121314151617181920212223242526272829303132class TStep(BaseModel): &quot;&quot;&quot; 测试步骤，里面包含了request请求 它继承自 BaseModel。它定义了一些属性，用于表示测试步骤的相关信息，包括名称、请求、测试用例、变量、setup 和 teardown 钩子、提取变量、导出变量、验证器、验证脚本、重试次数、重试间隔、Thrift 请求和 SQL 请求等。 其中，name 属性表示测试步骤的名称， request 属性表示 HTTP 请求的相关信息，是一个 TRequest 类型的对象， testcase 属性表示测试用例，可以是一个字符串或者是一个函数，字符串表示测试用例的 Python 代码，函数表示测试用例的函数对象， variables 属性表示变量，是一个字典，setup_hooks 属性表示 setup 钩子，是一个列表，列表中的元素可以是字符串或者是函数，字符串表示 setup 钩子的 Python 代码，函数表示 setup 钩子的函数对象，t eardown_hooks 属性表示 teardown 钩子，是一个列表，列表中的元素可以是字符串或者是函数，字符串表示 teardown 钩子的 Python 代码，函数表示 teardown 钩子的函数对象， extract 属性表示提取变量，是一个字典，export 属性表示导出变量，是一个列表，列表中的元素是字符串，表示要导出的变量名， validators 属性表示验证器，是一个列表，列表中的元素是一个字典，表示验证器的相关信息，validate_script 属性表示验证脚本，是一个列表，列表中的元素是字符串，表示验证脚本的 Python 代码， retry_times 属性表示重试次数， retry_interval 属性表示重试间隔， thrift_request 属性表示 Thrift 请求的相关信息，是一个 TThriftRequest 类型的对象， sql_request 属性表示 SQL 请求的相关信息，是一个 TSqlRequest 类型的对象。 &quot;&quot;&quot; name: Name request: Union[TRequest, None] = None testcase: Union[Text, Callable, None] = None variables: VariablesMapping = &#123;&#125; setup_hooks: Hooks = [] teardown_hooks: Hooks = [] # used to extract request&#x27;s response field extract: VariablesMapping = &#123;&#125; # used to export session variables from referenced testcase export: Export = [] validators: Validators = Field([], alias=&quot;validate&quot;) validate_script: List[Text] = [] retry_times: int = 0 retry_interval: int = 0 # sec thrift_request: Union[TThriftRequest, None] = None sql_request: Union[TSqlRequest, None] = None 这个类的作用是定义测试步骤的相关信息，方便用户进行接口测试。用户可以通过实例化对象来设置这些属性的值，然后将对象传递给 HttpRunner 类的相应方法，以执行相应的接口测试。在执行接口测试之前，用户需要先创建一个 HttpRunner 对象，并将配置信息传递给它。然后，用户可以通过调用 HttpRunner 对象的相应方法，传递 TStep 对象作为参数，来执行相应的接口测试。在执行测试步骤之前，用户需要先创建一个 TRequest 对象，并将 HTTP 请求的相关信息传递给它。然后，用户可以通过设置 TStep 对象的 request 属性，将 TRequest 对象作为参数传递给它，来定义测试步骤的 HTTP 请求。如果用户需要在测试步骤中执行测试用例，可以将测试用例的 Python 代码或者函数对象作为参数传递给 TStep 对象的 testcase 属性。如果用户需要在测试步骤中执行 setup 或 teardown 钩子，可以将钩子的Python 代码或者函数对象作为参数传递给 TStep 对象的 setup_hooks 或 teardown_hooks 属性。如果用户需要在测试步骤中提取变量，可以将变量名和提取规则作为参数传递给TStep 对象的 extract 属性。如果用户需要在测试步骤中导出变量，可以将变量名作为参数传递给 TStep 对象的 export 属性。如果用户需要在测试步骤中执行验证器，可以将验证器的相关信息作为参数传递给 TStep 对象的 validators 属性。如果用户需要在测试步骤中执行验证脚本，可以将验证脚本的 Python 代码作为参数传递给 TStep 对象的 validate_script 属性。如果用户需要在测试步骤中执行重试操作，可以将重试次数和重试间隔作为参数传递给 TStep 对象的 retry_times 和 retry_interval 属性。如果用户需要在测试步骤中执行 Thrift 请求，可以将 Thrift 请求的相关信息作为参数传递给 TStep 对象的 thrift_request 属性。如果用户需要在测试步骤中执行 SQL 请求，可以将 SQL 请求的相关信息作为参数传递给 TStep 对象的 sql_request 属性。 TestCase123456789class TestCase(BaseModel): &quot;&quot;&quot; 测试用例，包含了测试步骤和配置信息 它定义了一些属性，用于表示测试用例的相关信息，包括配置信息和测试步骤等。 config 属性表示配置信息，是一个 TConfig 类型的对象， teststeps 属性表示测试步骤，是一个 TStep 类型的对象的列表。 &quot;&quot;&quot; config: TConfig teststeps: List[TStep] ProjectMeta1234567891011121314151617181920class ProjectMeta(BaseModel): &quot;&quot;&quot; 项目结构 定义了一些属性，用于表示项目的相关信息， debugtalk.py 文件的内容和路径、.env 文件的路径、在 debugtalk.py 中定义的函数、环境变量和项目根目录等。 其中，debugtalk_py 属性表示 debugtalk.py 文件的内容， debugtalk_path 属性表示 debugtalk.py 文件的路径， dot_env_path 属性表示 .env 文件的路径， functions 属性表示在 debugtalk.py 中定义的函数，是一个字典， env 属性表示环境变量，是一个字典， RootDir 属性表示项目根目录，是一个字符串，表示 debugtalk.py 文件所在的目录。 &quot;&quot;&quot; debugtalk_py: Text = &quot;&quot; # debugtalk.py file content debugtalk_path: Text = &quot;&quot; # debugtalk.py file path dot_env_path: Text = &quot;&quot; # .env file path functions: FunctionsMapping = &#123;&#125; # functions defined in debugtalk.py env: Env = &#123;&#125; RootDir: Text = ( os.getcwd() ) # project root directory (ensure absolute), the path debugtalk.py located TestsMapping12345678class TestsMapping(BaseModel): &quot;&quot;&quot; 测试映射 1.project_meta 2.testcases 测试用例集，list下有多个用例 &quot;&quot;&quot; project_meta: ProjectMeta testcases: List[TestCase] TestCaseTime12345678910class TestCaseTime(BaseModel): &quot;&quot;&quot; 测试用例时间 1.start_at：开始时间默认为0 2.start_at_iso_format：以iso格式启动 3.duration：持续时间 &quot;&quot;&quot; start_at: float = 0 start_at_iso_format: Text = &quot;&quot; duration: float = 0 TestCaseInOut123456789class TestCaseInOut(BaseModel): &quot;&quot;&quot; 测试用例的输入输出： config_vars：配置变量 export_vars：导出变量 &quot;&quot;&quot; config_vars: VariablesMapping = &#123;&#125; export_vars: Dict = &#123;&#125; RequestStat12345678910class RequestStat(BaseModel): &quot;&quot;&quot; 请求指标： content_size：内容大小 response_time_ms：响应时间(ms) elapsed_ms：逝去的时间(ms) &quot;&quot;&quot; content_size: float = 0 response_time_ms: float = 0 elapsed_ms: float = 0 AddressData123456789101112class AddressData(BaseModel): &quot;&quot;&quot; 客户端与服务器地址数据 client_ip：客户端ip地址 client_port：客户端端口号 server_ip：服务器ip地址 server_port：服务器端口号 &quot;&quot;&quot; client_ip: Text = &quot;N/A&quot; client_port: int = 0 server_ip: Text = &quot;N/A&quot; server_port: int = 0 RequestData1234567891011121314class RequestData(BaseModel): &quot;&quot;&quot; 请求数据 method：请求方法，默认为GET url：url地址 headers：请求头 cookies：cookie信息 body：请求体 &quot;&quot;&quot; method: MethodEnum = MethodEnum.GET url: Url headers: Headers = &#123;&#125; cookies: Cookies = &#123;&#125; body: Union[Text, bytes, List, Dict, None] = &#123;&#125; ResponseData12345678910111213141516class ResponseData(BaseModel): &quot;&quot;&quot; 响应数据 status_code：状态码 headers：响应头 cookies：cookie信息 encoding：编码格式 content_type：内容类型 body：响应体 &quot;&quot;&quot; status_code: int headers: Dict cookies: Cookies encoding: Union[Text, None] = None content_type: Text body: Union[Text, bytes, List, Dict, None] ReqRespData12345678class ReqRespData(BaseModel): &quot;&quot;&quot; 请求响应数据 request：RequestData response：ResponseData &quot;&quot;&quot; request: RequestData response: ResponseData SessionData123456789101112131415161718class SessionData(BaseModel): &quot;&quot;&quot; request session data, including request, response, validators and stat data 它定义了一些属性，用于表示请求会话数据，包括请求、响应、验证器和统计数据等。 success 属性表示请求是否成功，是一个布尔值， req_resps 属性表示请求和响应数据，是一个 ReqRespData 类型的对象的列表， stat 属性表示请求统计数据，是一个 RequestStat 类型的对象， address 属性表示请求地址数据，是一个 AddressData 类型的对象， validators 属性表示验证器，是一个字典 &quot;&quot;&quot; success: bool = False # in most cases, req_resps only contains one request &amp; response # while when 30X redirect occurs, req_resps will contain multiple request &amp; response req_resps: List[ReqRespData] = [] stat: RequestStat = RequestStat() address: AddressData = AddressData() validators: Dict = &#123;&#125; StepResult1234567891011121314151617181920212223242526class StepResult(BaseModel): &quot;&quot;&quot; teststep data, each step maybe corresponding to one request or one testcase 它定义了一些属性，用于表示测试步骤的相关信息，包括测试步骤名称、测试步骤类型、请求会话数据、测试步骤执行时间、响应内容大小、导出变量和附件等。其中， name 属性表示测试步骤名称，是一个字符串， step_type 属性表示测试步骤类型，是一个字符串， success 属性表示测试步骤是否成功，是一个布尔值， data 属性表示请求会话数据，是一个 SessionData 类型的对象或 StepResult 类型的对象的列表， elapsed 属性表示测试步骤执行时间，是一个浮点数， content_size 属性表示响应内容大小，是一个浮点数， export_vars 属性表示导出变量，是一个字典， attachment 属性表示测试步骤的附件，是一个字符串。 &quot;&quot;&quot; name: Text = &quot;&quot; # teststep name step_type: Text = &quot;&quot; # teststep type, request or testcase success: bool = False data: Union[SessionData, List[&quot;StepResult&quot;]] = None elapsed: float = 0.0 # teststep elapsed time content_size: float = 0 # response content size export_vars: VariablesMapping = &#123;&#125; attachment: Text = &quot;&quot; # teststep attachmentStepResult.update_forward_refs() IStep123456789101112131415161718192021class IStep(object): &quot;&quot;&quot; 它定义了一些方法，用于表示测试步骤的相关信息，包括测试步骤名称、测试步骤类型、测试步骤结构和测试步骤执行等。 name 方法返回测试步骤名称，是一个字符串， type 方法返回测试步骤类型，是一个字符串， struct 方法返回测试步骤结构，是一个 TStep 类型的对象， run 方法用于执行测试步骤，接受一个 runner 参数，返回一个 StepResult 类型的对象。 &quot;&quot;&quot; def name(self) -&gt; str: raise NotImplementedError def type(self) -&gt; str: raise NotImplementedError def struct(self) -&gt; TStep: raise NotImplementedError def run(self, runner) -&gt; StepResult: # runner: HttpRunner raise NotImplementedError TestCaseSummary1234567891011class PlatformInfo(BaseModel): &quot;&quot;&quot; 平台信息 httprunner_version：httprunner版本号 python_version：python版本 platform：平台 &quot;&quot;&quot; httprunner_version: Text python_version: Text platform: Text PlatformInfo12345678910class PlatformInfo(BaseModel): &quot;&quot;&quot; 平台信息 httprunner_version：httprunner版本号 python_version：python版本 platform：平台 &quot;&quot;&quot; httprunner_version: Text python_version: Text platform: Text Stat12345678910class Stat(BaseModel): &quot;&quot;&quot; 统计信息 total：总数 success：成功的用例数 fail：失败的用例数 &quot;&quot;&quot; total: int = 0 success: int = 0 fail: int = 0 TestSuiteSummary12345678910111213141516class TestSuiteSummary(BaseModel): &quot;&quot;&quot; 测试套件结果 success：成功的状态 stat：统计信息 time：测试用例花费的时间 platform：平台信息 testcases：测试用例集 &quot;&quot;&quot; success: bool = False stat: Stat = Stat() time: TestCaseTime = TestCaseTime() platform: PlatformInfo testcases: List[TestCaseSummary]","categories":[{"name":"Httprunner","slug":"Httprunner","permalink":"http://example.com/categories/Httprunner/"}],"tags":[{"name":"httprunner","slug":"httprunner","permalink":"http://example.com/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Httprunner源码解读(1)源码模块内容","slug":"Httprunner源码解读-1-源码模块内容","date":"2023-06-10T03:12:13.000Z","updated":"2024-11-22T04:10:55.248Z","comments":true,"path":"2023/06/10/Httprunner源码解读-1-源码模块内容/","link":"","permalink":"http://example.com/2023/06/10/Httprunner%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1-%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97%E5%86%85%E5%AE%B9/","excerpt":"前言由于团队要基于httprunner开展接口自动化测试，本人后续也想基于httprunner测试框架搭建一个API测试平台，而且目前很多开源的测试平台都是基于httprunner，所以，读懂源码必不可少","text":"前言由于团队要基于httprunner开展接口自动化测试，本人后续也想基于httprunner测试框架搭建一个API测试平台，而且目前很多开源的测试平台都是基于httprunner，所以，读懂源码必不可少 源码结构 builtin这个包做了一些内置的功能 123├── __init__.py├── comparators.py└── functions.py comparators：内置验证校验器 functions：内置的一些方法 database1└── engine.py 数据库模块是基于 DBEngine 实现的，用于对测试数据进行存储和管理。它支持多种类型数据库，如 MySQL、PostgreSQL、SQLite 等 engine.py实现了一个数据库引擎类DBEngine，用于连接数据库并执行SQL语句。在初始化时，它会根据传入的数据库URI创建一个SQLAlchemy的engine，并使用sessionmaker创建一个session。在执行SQL语句时，它会根据语句的类型（SELECT、UPDATE、DELETE、INSERT）返回不同的结果。如果是SELECT语句，它会根据size参数返回对应数量的结果，如果size为1，则返回一个字典，否则返回一个字典列表。在返回结果前，它会对结果进行处理，将datetime.datetime和datetime.date类型转换为字符串，将json字符串转换为字典。如果是UPDATE、DELETE、INSERT语句，则返回一个字典，包含受影响的行数。 ext123├── __init__.py└── uploader └── __init__.py 在httprunner基础上集成了别的插件 uploader：集成了上传文件的功能这是一个名为uploader的HTTPRunner扩展，它提供了上传文件的功能。如果要使用此扩展，需要先安装以下依赖项： requests_toolbelt filetype uploader扩展提供了prepare_upload_step函数，用于预处理上传测试步骤。它会将上传信息替换为MultipartEncoder对象。如果上传信息不存在，则不进行处理。MultipartEncoder对象是使用multipart_encoder函数初始化的，该函数接受上传字段作为参数，并返回一个初始化的MultipartEncoder对象。multipart_content_type函数用于准备请求头的Content-Type。如果依赖项未安装，则会引发ModuleNotFoundError异常。 thrift12├── data_convertor.py└── thrift_client.py thrift 模块是用于支持 Apache Thrift 的模块，可以将 thrift 服务定义文件（.thrift 文件）转换为 Python 代码，并生成可用的客户端和服务端代码。它基于 thrift 的 Python 库进行开发，支持多种类型的 thrift 服务，如 TCP、HTTP 等。 cli.py命令行驱动执行 client.py客户端相关方法,主要是封装 requests.Session.request,安全调用,输出log等, 给runner.py调用. compat.py提供各种处理兼容性的方法,包括让v2版本的用例能在v3版本继续运行的相关转换方法 config.py包含三个类：ConfigThrift、ConfigDB 和 Config。这些类的作用是为 HttpRunner 提供配置信息，包括 Thrift 协议相关的配置信息和数据库相关的配置信息。通过使用这些类，用户可以方便地设置和管理配置信息，从而更好地控制测试用例的执行过程。 exceptions.py定义了失败类型的异常信息 loader.py加载文件内容的方法 make.py主要集成参数使之生效在测试用例中，如config、request、teststep等等，构成一个可用的用例 models.py定义各种model类,以BaseModel为父类 parser.py各种解析方法，主要用于数值类型判断后自动转换 response.py处理响应报文格式 runner.py运行项目的核心 step.py文件定义了 Step 类，该类表示 HttpRunner 测试用例中的一个步骤，提供了多个属性和方法，用于获取步骤的信息和运行步骤 step_request.py用于运行 HttpRunner 测试步骤中的请求 step_sql_request.py定义了 run_step_sql_request 函数，该函数表示 HttpRunner 测试用例中的一个 SQL 查询步骤，提供了解析 SQL 查询请求、执行 SQL 查询、提取 SQL 查询结果、更新 step_variables 和验证 SQL 查询结果等功能。 step_testcase.py定义了 StepTestCase 类，该类表示 HttpRunner 测试用例中的一个测试步骤，继承自 Step 类，提供了多个属性和方法，用于获取测试步骤的信息和运行测试步骤 step_thrift_request.py定义了 run_step_thrift_request 函数，该函数表示 HttpRunner 测试用例中的一个 Thrift 请求步骤，提供了解析 Thrift 请求、执行 Thrift 请求、提取 Thrift 请求结果、更新 step_variables 和验证 Thrift 请求结果等功能。 utils.py一些工具函数用于处理数据、打印信息等,辅助测试用例的编写和执行，可以在测试用例中直接使用。","categories":[{"name":"Httprunner","slug":"Httprunner","permalink":"http://example.com/categories/Httprunner/"}],"tags":[{"name":"httprunner","slug":"httprunner","permalink":"http://example.com/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Git使用详细教程","slug":"Git使用详细教程","date":"2023-06-05T05:37:53.000Z","updated":"2023-06-17T03:26:10.342Z","comments":true,"path":"2023/06/05/Git使用详细教程/","link":"","permalink":"http://example.com/2023/06/05/Git%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言现在大部分的开发团队都以 Git 作为自己的版本控制工具，需要对 Git 的使用非常的熟悉。这篇文章中本人整理了自己在工作过程中经常使用到的 Git 命令，方便在偶尔忘记时速查。","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Jmeter压测-Linux运行Jmeter环境","slug":"Jmeter压测-Linux运行Jmeter环境","date":"2023-06-05T04:13:37.000Z","updated":"2024-11-22T04:11:16.298Z","comments":true,"path":"2023/06/05/Jmeter压测-Linux运行Jmeter环境/","link":"","permalink":"http://example.com/2023/06/05/Jmeter%E5%8E%8B%E6%B5%8B-Linux%E8%BF%90%E8%A1%8CJmeter%E7%8E%AF%E5%A2%83/","excerpt":"前言使用jmeter做压测的时候，在windows上不太稳定，所有一直在linux服务器上使用jmeter做压力测试。本篇记录下linux上搭建jmeter环境，以及运行jmeter脚本，查看报告。","text":"前言使用jmeter做压测的时候，在windows上不太稳定，所有一直在linux服务器上使用jmeter做压力测试。本篇记录下linux上搭建jmeter环境，以及运行jmeter脚本，查看报告。 相关环境：java 1.8jmeter 5.5 一、java环境先在Linux上安装java环境，安装1.8.0版本，先查找java相关的列表 1yum -y list java* 安装java-1.8.0-openjdk相关的文件 1yum -y install java-1.8.0-openjdk* 安装完成后环境变量自动已经生效了，输入java -version查看版本号 1java -version 二、安装jmeter在jmeter官网https://jmeter.apache.org/下载jmeter的zip安装包,下载完成后传到linux上任意目录，比如我的是/root/jmeter。使用unzip命令解压zip文件，如果没有安装过unzip，先yum安装下 1yum -y install unzip 使用unzip 解压.zip 文件 1unzip apache-jmeter-5.5.zip 解压完成后，接下来vi编辑&#x2F;etc&#x2F;profile文件，设置环境变量,在文件底部编辑 1export PATH=/root/jmeter/apache-jmeter-5.5/bin/:$PATH 接下来source执行&#x2F;etc&#x2F;profile文件让环境变量生效 1source /etc/profile 输入jmeter -v能看到内容说明安装成功了 1jmeter -v 三、启动jmeter脚本测试脚本文件(Test Plan.jmx)导入linux服务器上,执行以下命令启动测试计划 1jmeter -n -t Test\\ Plan.jmx -l testplan.jtl 参数说明： n 表示以no gui方式运行测试计划 t 表示测试计划，后面跟测试计划名称, 有空格的话用\\空格表示 l表示测试结果，后面跟测试结果文件名称，后缀是.jtl文件 四、查看报告文件测试结束后导出testplan.jtl文件，在本地jmeter上查看运行结果","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Jmeter","slug":"Jmeter","permalink":"http://example.com/tags/Jmeter/"},{"name":"性能测试","slug":"性能测试","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Docker安装jenkins教程","slug":"Docker安装jenkins教程","date":"2023-06-01T06:22:12.000Z","updated":"2024-11-22T04:10:50.263Z","comments":true,"path":"2023/06/01/Docker安装jenkins教程/","link":"","permalink":"http://example.com/2023/06/01/Docker%E5%AE%89%E8%A3%85jenkins%E6%95%99%E7%A8%8B/","excerpt":"一、jenkins安装1.查找，下载jenkins镜像文件 1docker search jenkins 下载Jenkins镜像文件 1docker pull jenkins/jenkins:lts","text":"一、jenkins安装1.查找，下载jenkins镜像文件 1docker search jenkins 下载Jenkins镜像文件 1docker pull jenkins/jenkins:lts 2.创建Jenkins挂载目录并授权权限，这样我们就可以很方便地对容器内的配置文件进行修改。 123mkdir -p /data/jenkins_home/chmod 777 /data/jenkins_home/ 3.创建并启动Jenkins容器 123456docker run -d --name jenkins \\ -p 8080:8080 -p 50000:50000 \\ -v /root/Yoga/data/jenkins_home:/var/jenkins_home \\ -e TZ=Asia/Shanghai \\ jenkins/jenkins:lts -d 后台运行镜像 -p 8080:8080 -p 50000:50000 表示将容器内部的 8080 和 50000 端口映射到主机的 8080 和 50000 端口 -v &#x2F;root&#x2F;Yoga&#x2F;data&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home &#x2F;var&#x2F;jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 &#x2F;data&#x2F;jenkins_home目录 -e TZ&#x3D;Asia&#x2F;Shanghai 表示设置时区为亚洲上海时区。 –name myjenkins 给容器起一个别名 4.查看jenkins是否启动成功，如下图出现端口号，就为启动成功了 1docker ps -l 5.查看docker容器日志 1docker logs jenkins 6.配置镜像加速，进入 cd &#x2F;data&#x2F;jenkins_home 目录 123修改hudson.model.UpdateCenter.xml里的内容将 url 修改为清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 7.访问Jenkins页面，输入你的ip加上8090 8.管理员密码获取方法，编辑initialAdminPassword文件查看，把密码输入登录中的密码即可，开始使用。 1cat /root/Yoga/data/jenkins_home/secrets/initialAdminPassword","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"http://example.com/categories/Linux/Docker/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://example.com/tags/jenkins/"}]},{"title":"Centos安装docker教程","slug":"Centos安装docker教程","date":"2023-05-31T09:46:14.000Z","updated":"2024-11-22T04:10:41.348Z","comments":true,"path":"2023/05/31/Centos安装docker教程/","link":"","permalink":"http://example.com/2023/05/31/Centos%E5%AE%89%E8%A3%85docker%E6%95%99%E7%A8%8B/","excerpt":"一、安装前必读在安装 Docker 之前，先说一下配置，我这里是Centos7Linux 内核：官方建议 3.10 以上，3.8以上貌似也可。","text":"一、安装前必读在安装 Docker 之前，先说一下配置，我这里是Centos7Linux 内核：官方建议 3.10 以上，3.8以上貌似也可。 1.查看当前的内核版本 1uname -r 2.使用 root 权限更新 yum 包（生产环境中此步操作需慎重，看自己情况，学习的话随便搞） 1yum -y update 这个命令不是必须执行的，看个人情况，后面出现不兼容的情况的话就必须update了 注意 12yum -y update：升级所有包同时也升级软件和系统内核；yum -y upgrade：只升级所有包，不升级软件和系统内核 3.卸载旧版本（如果之前安装过的话） 1yum remove docker docker-common docker-selinux docker-engine 二、安装Docker的详细步骤1.安装需要的软件包， yum-util 提供yum-config-manager功能，另两个是devicemapper驱动依赖 1yum install -y yum-utils device-mapper-persistent-data lvm2 2.设置 yum 源 设置一个yum源，下面两个都可用 123yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库） 3.选择docker版本并安装（1）查看可用版本有哪些 1yum list docker-ce --showduplicates | sort -r （2）选择一个版本并安装：yum install docker-ce-版本号 1yum -y install docker-ce-18.06.0.ce-3.el7 4.启动 Docker 并设置开机自启 12systemctl start dockersystemctl enable docker","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"http://example.com/categories/Linux/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"如何在 Django REST Framework 中使用 JWT 身份验证","slug":"如何在-Django-REST-Framework-中使用-JWT-身份验证","date":"2023-05-28T07:46:05.000Z","updated":"2024-11-22T04:10:32.160Z","comments":true,"path":"2023/05/28/如何在-Django-REST-Framework-中使用-JWT-身份验证/","link":"","permalink":"http://example.com/2023/05/28/%E5%A6%82%E4%BD%95%E5%9C%A8-Django-REST-Framework-%E4%B8%AD%E4%BD%BF%E7%94%A8-JWT-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","excerpt":"JWT 代表JSON Web Token，它是客户端&#x2F;服务器应用程序使用的一种身份验证策略，其中客户端是使用 JavaScript 和一些前端框架（如 Angular、React 或 VueJS）的 Web 应用程序。","text":"JWT 代表JSON Web Token，它是客户端&#x2F;服务器应用程序使用的一种身份验证策略，其中客户端是使用 JavaScript 和一些前端框架（如 Angular、React 或 VueJS）的 Web 应用程序。 JWT 是如何工作的？JWT 只是一个授权令牌，应该包含在所有请求中： 1curl http://127.0.0.1:8000/hello/ -H &#x27;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQzODI4NDMxLCJqdGkiOiI3ZjU5OTdiNzE1MGQ0NjU3OWRjMmI0OTE2NzA5N2U3YiIsInVzZXJfaWQiOjF9.Ju70kdcaHKn1Qaz8H42zrOYk0Jx9kIckTn9Xx7vhikY&#x27; JWT 是通过将用户名+密码交换为访问令牌和刷新令牌来获取的。 访问令牌通常是短暂的（5 分钟左右过期，但可以自定义）。 刷新令牌的寿命稍长一些（24 小时后过期，也可自定义）。它类似于身份验证会话。过期后，您需要再次使用用户名+密码进行完整登录。 这是为什么？ 这是一项安全功能，也是因为 JWT 拥有更多信息。如果你仔细看我上面给出的例子，你会看到令牌由三部分组成： 1xxxxx.yyyyy.zzzzz 这些是构成 JWT 的三个独特部分： 1header.payload.signature 所以我们在这里： 123header = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9payload = eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQzODI4NDMxLCJqdGkiOiI3ZjU5OTdiNzE1MGQ0NjU3OWRjMmI0OTE2NzA5N2U3YiIsInVzZXJfaWQiOjF9signature = Ju70kdcaHKn1Qaz8H42zrOYk0Jx9kIckTn9Xx7vhikY 此信息使用 Base64 编码。如果我们解码，我们会看到这样的东西： 标头 1234&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125; 有效负载 123456&#123; &quot;token_type&quot;: &quot;access&quot;, &quot;exp&quot;: 1543828431, &quot;jti&quot;: &quot;7f5997b7150d46579dc2b49167097e7b&quot;, &quot;user_id&quot;: 1&#125; 签名 签名由 JWT 后端发出，使用 header base64 + payload base64 + SECRET_KEY。根据每个请求验证此签名。如果客户端更改了标头或有效负载中的任何信息，它将使签名无效。检查和验证签名的唯一方法是使用应用程序的 SECRET_KEY. 除此之外，这就是为什么您应该始终保守SECRET_KEY 秘密！ 安装与设置对于本教程，我们将使用djangorestframework_simplejwt DRF 开发人员推荐的库。 1pip install djangorestframework_simplejwt 设置.py 12345REST_FRAMEWORK = &#123; &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: [ &#x27;rest_framework_simplejwt.authentication.JWTAuthentication&#x27;, ],&#125; 网址.py 12345678from django.urls import pathfrom rest_framework_simplejwt import views as jwt_viewsurlpatterns = [ # Your URLs... path(&#x27;api/token/&#x27;, jwt_views.TokenObtainPairView.as_view(), name=&#x27;token_obtain_pair&#x27;), path(&#x27;api/token/refresh/&#x27;, jwt_views.TokenRefreshView.as_view(), name=&#x27;token_refresh&#x27;),] 示例代码对于本教程，我将使用以下路由和 API 视图： 视图.py 1234567891011from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.permissions import IsAuthenticatedclass HelloView(APIView): permission_classes = (IsAuthenticated,) def get(self, request): content = &#123;&#x27;message&#x27;: &#x27;Hello, World!&#x27;&#125; return Response(content) 网址.py 123456from django.urls import pathfrom myapi.core import viewsurlpatterns = [ path(&#x27;hello/&#x27;, views.HelloView.as_view(), name=&#x27;hello&#x27;),] 用法我将使用HTTPie通过终端使用 API 端点。但您也可以使用 cURL（在许多操作系统中都很容易使用）在本地进行尝试。 或者，通过访问端点 URL 来使用 DRF Web 界面，如下所示： 获取令牌第一步是验证并获取令牌。端点是/api/token/，它只接受POST请求。 1http post http://127.0.0.1:8000/api/token/ username=vitor password=123 所以基本上你的响应主体是两个标记： 1234&#123; &quot;access&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQ1MjI0MjU5LCJqdGkiOiIyYmQ1NjI3MmIzYjI0YjNmOGI1MjJlNThjMzdjMTdlMSIsInVzZXJfaWQiOjF9.D92tTuVi_YcNkJtiLGHtcn6tBcxLCBxz9FKD3qzhUg8&quot;, &quot;refresh&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTU0NTMxMDM1OSwianRpIjoiMjk2ZDc1ZDA3Nzc2NDE0ZjkxYjhiOTY4MzI4NGRmOTUiLCJ1c2VyX2lkIjoxfQ.rA-mnGRg71NEW_ga0sJoaMODS5ABjE5HnxJDb0F8xAo&quot;&#125; 之后，您将在客户端存储访问令牌和刷新令牌，通常在localStorage中。 为了访问后端受保护的视图（即需要身份验证的 API 端点），您应该在所有请求的标头中包含访问令牌，如下所示： 1http http://127.0.0.1:8000/hello/ &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQ1MjI0MjAwLCJqdGkiOiJlMGQxZDY2MjE5ODc0ZTY3OWY0NjM0ZWU2NTQ2YTIwMCIsInVzZXJfaWQiOjF9.9eHat3CvRQYnb5EdcgYFzUyMobXzxlAVh_IAgqyvzCE&quot; 您可以在接下来的五分钟内使用此访问令牌。 五分钟后，令牌将过期，如果您再次尝试访问该视图，您将收到以下错误： 1http http://127.0.0.1:8000/hello/ &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQ1MjI0MjAwLCJqdGkiOiJlMGQxZDY2MjE5ODc0ZTY3OWY0NjM0ZWU2NTQ2YTIwMCIsInVzZXJfaWQiOjF9.9eHat3CvRQYnb5EdcgYFzUyMobXzxlAVh_IAgqyvzCE&quot; 刷新令牌要获取新的访问令牌/api/token/refresh/，您应该使用发布 刷新令牌的刷新令牌端点： 1http post http://127.0.0.1:8000/api/token/refresh/ refresh=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTU0NTMwODIyMiwianRpIjoiNzAyOGFlNjc0ZTdjNDZlMDlmMzUwYjg3MjU1NGUxODQiLCJ1c2VyX2lkIjoxfQ.Md8AO3dDrQBvWYWeZsd_A1J39z6b6HEwWIUZ7ilOiPE 返回的是一个新的访问令牌，您应该在后续请求中使用它。 刷新令牌在接下来的 24 小时内有效。当它最终也过期时，用户将需要使用他们的用户名和密码再次执行完全身份验证以获得一组新的访问令牌+刷新令牌。 刷新令牌有什么意义？乍一看，刷新令牌可能看起来毫无意义，但实际上有必要确保用户仍然拥有正确的权限。如果您的访问令牌的过期时间很长，则更新与令牌关联的信息可能需要更长的时间。这是因为身份验证检查是通过密码学手段完成的，而不是查询数据库和验证数据。所以一些信息有点缓存。 还有一个安全方面，从某种意义上说，刷新令牌仅在 POST 数据中传输。并且 访问令牌是通过 HTTP 标头发送的，该标头可能会在传输过程中被记录下来。因此，如果您的访问令牌被泄露，这也会提供一个较短的窗口。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"后端/Django","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"rest_framework","slug":"rest-framework","permalink":"http://example.com/tags/rest-framework/"}]},{"title":"Markdown常用语法介绍","slug":"Markdown常用语法介绍","date":"2023-05-27T04:25:22.000Z","updated":"2024-11-22T04:11:21.753Z","comments":true,"path":"2023/05/27/Markdown常用语法介绍/","link":"","permalink":"http://example.com/2023/05/27/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"1、Markdown标题 —— 提升标题等级ctrl +1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题","text":"1、Markdown标题 —— 提升标题等级ctrl +1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2、Markdown字体 用1个星号*或底线_表示斜体 斜体：Ctrl+I 用2个星号*或底线_表示粗体 加粗：Ctrl+B 用3个星号*或底线_表示粗斜体1234567891011*斜体文字*_斜体文字_**粗体文字**__粗体文字__***粗斜体文字***___粗斜体文字___ 3、Markdown分割线123*********------ 4、Markdown删除线 —— 删除线：Alt+Shift+51~~tencent.com~~ 5、代码块 —— 代码：Ctrl+Shift+&#96;1`world` 6、Markdown下划线 —— 下划线：Ctrl+U1&lt;u&gt;带下划线文本&lt;/u&gt; 7、Markdown列表无序列表(三个都行） 1234567891011* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符。 1231. 第一项2. 第二项3. 第三项 8、Markdown嵌套列表1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 9、Markdown链接 —— 超链接：Ctrl+K12这是一个链接 [新浪新闻](https://news.sina.com.cn/)&lt;https://news.sina.com.cn/&gt; 10、Markdown图片 —— 图像：Ctrl+Shift+I12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 11、Markdown表格 —— ctrl + T 插入表格123456789| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 || 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 12、Markdown高亮 —— ctrl + T 插入表格1==高亮==","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]},{"title":"如何进行技术面试（面试官视角）","slug":"如何进行技术面试（面试官视角）","date":"2023-02-28T03:49:29.000Z","updated":"2024-11-22T04:10:26.783Z","comments":true,"path":"2023/02/28/如何进行技术面试（面试官视角）/","link":"","permalink":"http://example.com/2023/02/28/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9D%A2%E8%AF%95%E5%AE%98%E8%A7%86%E8%A7%92%EF%BC%89/","excerpt":"说起来在我第一次做面试官之前，并没有人教过我应该怎么做，我则一直将面试视作通过一小时左右的沟通，对候选人形成一个整体的印象，最后给出一个主观的评价的过程。在这么多次的面试中，我也总结出了一些经验可以和大家分享。","text":"说起来在我第一次做面试官之前，并没有人教过我应该怎么做，我则一直将面试视作通过一小时左右的沟通，对候选人形成一个整体的印象，最后给出一个主观的评价的过程。在这么多次的面试中，我也总结出了一些经验可以和大家分享。 验证简历真实性首先花一些时间聊一聊简历上提到的项目，请对方进一步介绍这个项目的业务、自己在其中承担的职责和遇到的问题。然后针对其中自己了解的部分提几个问题，如「据我所知这类项目的难点是某某方面，请问你是否有遇到、是如何解决的」，确认对方的项目经验是否真实、是否比较深度地参与了项目。 围绕简历提问尽量提问对方了解和擅长的话题，让对方有足够的表达机会，发挥出正常水平，考察候选人擅长的部分要比不擅长的部分更有价值。 开放性问题避免问有标准答案的问题，而是可以问「遇到某种情况时可能是什么原因、你会怎么做」或「请解释一下某个事物是如何工作的」这样开放性的问题，给对方足够的发挥空间、主动提到一些自己的知识和经验。 也许有些候选人不喜欢这样的问题，认为缺少安全感、不知道该说什么，但我觉得开放性问题才有足够的区分度，才能在短时间内对候选人形成立体的印象。我们可以在候选人实在不知道从何说起时，对问题再做进一步的解释和提示。 围绕话题由浅入深应该针对同一话题准备多个难度逐步增加的问题，让对方回答时思路能够相对流畅，更容易考察对方在这一话题上的深度；反过来应该避免大量零散、无联系、无难度区分的小问题。 没必要执着于答案有时在反复提示下对方的答案仍差那么一点，在面试时间大多比较紧张的情况下，我们没必要花更多的时间去让对方答出答案。在候选人表示无法准确回答问题时，也可以引导他做出一些合理的猜测（这时的重点在于猜测是否合理而不是是否正确）。只要候选人在这一问题上说足够多的话，我们就可以考察到其水平了，不一定要等他说出最后的答案。 自己不懂也没关系 在一开始，我会担心问出的问题我自己也不了解，对方回答之后会把自己问倒或者无法考察对方水平。但后来发现完全没有必要，因为面试官没有义务即时地对候选人的回答做出评价（告诉对方对还是错），即使对于不了解的话题，自己也可以从对方的自信程度、逻辑层面，对回答有一个大体的判断的。 现场编码可以很简单候选人在现场会非常紧张，面试时间也有限，在现场编码环节没必要出太难的题，重点在于考察候选人是否有最基本编程思维和编码能力。例如我觉得一些难度不高，但适合用递归解决的题目会比较合适，可以考虑在候选人编码的过程中一直保持沟通，注重过程而不是结果。 同时我反对为候选人在面试前或面试后布置编码的作业，这会让候选人付出不对等的时间去准备面试，也很容易从「考察候选人的能力」变成「考察候选人的诚意」。 重复使用一套题库没什么问题可以自己建立自己的面试题库，在一次次面试中对其进行反复地打磨，让问题更准确、考察更全面。有些话题可能是永远都不过时的，例如对于后端工程师可能是并发模型及与之相关的线程、内存等话题。 给对方提问的机会一般面试的最后一个步骤是让候选人提问，不要把这个过程敷衍掉，可以引导对方提问，告诉对方都可以问哪些问题。如可以补充一下没有提及的技术话题、可以问我司的技术架构或选型、可以问所面试的职位和如果入职之后所参与的项目、可以问日常工作环境和时间等。这样可以让对方有一个主动打开话题的机会，互相判断需求是否匹配，即使没有通过面试也让对方对公司有一个比较好的印象。 有任何顾虑都可以 pass 掉我们前面做了这么多都是为了让候选人有更好的面试体验、发挥出自己最好的水平。这种情况下如果仍对候选人某一方面的表现有顾虑的话，应该果断地拒绝掉，招进来一个不合适的人损失远比错过一个合适的人大。 沟通是否顺畅很重要沟通是后续开展一切工作的基础，如果觉得与候选人的沟通不顺畅，对方总是不能理解自己的意思，那么即使候选人的技术水平满足要求，也应该慎重考虑。 留下面试的记录我每次面试结束后都会尽快开始写对候选人的评价，大多在一两百字，先列出面试聊到的内容、觉得好和不好的地方、了解到的对方的技术栈，然后总结一下对候选人技术水平和沟通情况的评价。这样可以帮助自己整理思路，在候选人比较多的时候也不会记混，最后给出通过与否的评价，同时还能给下一轮的面试官提供参考。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"那些有趣的注释，有没有你曾用过的","slug":"那些有趣的注释，有没有你曾用过的","date":"2023-02-27T03:12:07.000Z","updated":"2024-11-22T04:10:21.245Z","comments":true,"path":"2023/02/27/那些有趣的注释，有没有你曾用过的/","link":"","permalink":"http://example.com/2023/02/27/%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%B3%A8%E9%87%8A%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%A0%E6%9B%BE%E7%94%A8%E8%BF%87%E7%9A%84/","excerpt":"闲来无事收集了一些有趣的注释，各式各样的都有，程序员真是一群有趣的人，喜欢哪一款拿走不谢","text":"闲来无事收集了一些有趣的注释，各式各样的都有，程序员真是一群有趣的人，喜欢哪一款拿走不谢 第一款：佛祖保佑，永无BUG 123456789101112131415161718192021// _ooOoo_ // o8888888o // 88&quot; . &quot;88 // (| -_- |) // O\\ = /O // ____/`---&#x27;\\____ // . &#x27; \\\\| |// `. // / \\\\||| : |||// \\ // / _||||| -:- |||||- \\ // | | \\\\\\ - /// | | // | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | // \\ .-\\__ `-` ___/-. / // ___`. .&#x27; /--.--\\ `. . __ // .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. // | | : `- \\`.;`\\ _ /`;.`/ - ` : | | // \\ \\ `-. \\_ __\\ /__ _/ .-` / / // ======`-.____`-.___\\_____/___.-`____.-&#x27;====== // `=---=&#x27; // // ............................................. // 佛祖保佑 永无BUG 第二款：神兽护体，永无BUG 1234567891011121314151617// ┏┓ ┏┓// ┏┛┻━━━┛┻┓// ┃ ┃ // ┃ ━ ┃// ┃ ┳┛ ┗┳ ┃// ┃ ┃// ┃ ┻ ┃// ┃ ┃// ┗━┓ ┏━┛// ┃ ┃ Code is far away from bug with the animal protecting // ┃ ┃ 神兽保护，永无BUG！// ┃ ┗━━━┓// ┃ ┣┓// ┃ ┏┛// ┗┓┓┏━┳┓┏┛// ┃┫┫ ┃┫┫// ┗┻┛ ┗┻┛ 1234567891011121314151617181920212223/** * ┏┓ ┏┓+ + * ┏┛┻━━━┛┻┓ + + * ┃ ┃ * ┃ ━ ┃ ++ + + + * ████━████ ┃+ * ┃ ┃ + * ┃ ┻ ┃ * ┃ ┃ + + * ┗━┓ ┏━┛ * ┃ ┃ * ┃ ┃ + + + + * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,永无bug * ┃ ┃ * ┃ ┃ + * ┃ ┗━━━┓ + + * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ + + + + * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛+ + + + */ 第三款：来首程序员打油诗，笑 123456789101112/** * 江城子 . 程序员之歌 * * 十年生死两茫茫，写程序，到天亮。 * 千行代码，Bug何处藏。 * 纵使上线又怎样，朝令改，夕断肠。 * * 领导每天新想法，天天改，日日忙。 * 相顾无言，惟有泪千行。 * 每晚灯火阑珊处，夜难寐，加班狂。*/ 12345678910/** * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */ 第四款：单身狗专用 123456789101112131415161718192021222324252627282930313233343536&lt;!-- :: :;J7, :, ::;7: ,ivYi, , ;LLLFS: :iv7Yi :7ri;j5PL ,:ivYLvr ,ivrrirrY2X, :;r@Wwz.7r: :ivu@kexianli. :iL7::,:::iiirii:ii;::::,,irvF7rvvLujL7ur ri::,:,::i:iiiiiii:i:irrv177JX7rYXqZEkvv17 ;i:, , ::::iirrririi:i:::iiir2XXvii;L8OGJr71i :,, ,,: ,::ir@mingyi.irii:i:::j1jri7ZBOS7ivv, ,::, ::rv77iiiriii:iii:i::,rvLq@huhao.Li ,, ,, ,:ir7ir::,:::i;ir:::i:i::rSGGYri712: ::: ,v7r:: ::rrv77:, ,, ,:i7rrii:::::, ir7ri7Lri , 2OBBOi,iiir;r:: ,irriiii::,, ,iv7Luur: ,, i78MBBi,:,:::,:, :7FSL: ,iriii:::i::,,:rLqXv:: : iuMMP: :,:::,:ii;2GY7OBB0viiii:i:iii:i:::iJqL;:: , ::::i ,,,,, ::LuBBu BBBBBErii:i:i:i:i:i:i:r77ii , : , ,,:::rruBZ1MBBqi, :,,,:::,::::::iiriri: , ,,,,::::i: @arqiao. ,:,, ,:::ii;i7: :, rjujLYLi ,,:::::,:::::::::,, ,:i,:,,,,,::i:iii :: BBBBBBBBB0, ,,::: , ,:::::: , ,,,, ,,::::::: i, , ,8BMMBBBBBBi ,,:,, ,,, , , , , , :,::ii::i:: : iZMOMOMBBM2::::::::::,,,, ,,,,,,:,,,::::i:irr:i:::, i ,,:;u0MBMOG1L:::i:::::: ,,,::, ,,, ::::::i:i:iirii:i:i: : ,iuUuuXUkFu7i:iii:i:::, :,:,: ::::::::i:i:::::iirr7iiri:: : :rk@Yizero.i:::::, ,:ii:::::::i:::::i::,::::iirrriiiri::, : 5BMBBBBBBSr:,::rv2kuii:::iii::,:i:,, , ,,:,:i@petermu., , :r50EZ8MBBBBGOBBBZP7::::i::,:::::,: :,:,::i;rrririiii:: :jujYY7LS0ujJL7r::,::i::,::::::::::::::iirirrrrrrr:ii: ,: :@kevensun.:,:,,,::::i:i:::::,,::::::iir;ii;7v77;ii;i, ,,, ,,:,::::::i:iiiii:i::::,, ::::iiiir@xingjief.r;7:i, , , ,,,:,,::::::::iiiiiiiiii:,:,:::::::::iiir;ri7vL77rrirri:: :,, , ::::::::i:::i:::i:i::,,,,,:,::i:i:::iir;@Secbone.ii:::--&gt; 第五款：骷髅头 12345678910111213141516171819202122232425/** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&quot; &quot;-. | * * | / \\ | * * | _ | | _ | * * | ( \\ |, .-. .-. ,| / ) | * * | &gt; &quot;=._ | )(__/ \\__)( | _.=&quot; &lt; | * * | (_/&quot;=._&quot;=._ |/ /\\ \\| _.=&quot;_.=&quot;\\_) | * * | &quot;=._&quot;(_ ^^ _)&quot;_.=&quot; | * * | &quot;=\\__|IIIIII|__/=&quot; | * * | _.=&quot;| \\IIIIII/ |&quot;=._ | * * | _ _.=&quot;_.=&quot;\\ /&quot;=._&quot;=._ _ | * * | ( \\_.=&quot;_.=&quot; `--------` &quot;=._&quot;=._/ ) | * * | &gt; _.=&quot; &quot;=._ &lt; | * * | (_/ \\_) | * * | | * * &#x27;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#x27; * * * * LASCIATE OGNI SPERANZA, VOI CH&#x27;ENTRATE * ************************************************************** */ 第六款：标准键盘 12345678910111213141516/** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &#x27;│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 第七款：顶 123456789101112131415/** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 */ 还有一些其他有趣搞怪的注释 12345678910111213141516171819202122/** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ___/`---&#x27;\\____ * . &#x27; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | * \\ .-\\__ `-` ___/-. / * ___`. .&#x27; /--.--\\ `. . __ * .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#x27;====== * `=---=&#x27; * ............................................. * 佛曰：bug泛滥，我已瘫痪！ */ 123456789101112131415161718192021222324252627282930313233/** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * */ 上面这些都不能满足你，想要找更多的ascii图在这里http://www.asciiworld.com/","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}],"categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"Httprunner","slug":"Httprunner","permalink":"http://example.com/categories/Httprunner/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"http://example.com/categories/Linux/Docker/"},{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"后端/Django","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/Django/"},{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"数据迁移","slug":"数据迁移","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"},{"name":"httprunner","slug":"httprunner","permalink":"http://example.com/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"Jmeter","slug":"Jmeter","permalink":"http://example.com/tags/Jmeter/"},{"name":"性能测试","slug":"性能测试","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"jenkins","slug":"jenkins","permalink":"http://example.com/tags/jenkins/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"rest_framework","slug":"rest-framework","permalink":"http://example.com/tags/rest-framework/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"程序员","slug":"程序员","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}