{"meta":{"title":"佑珈","subtitle":"记录生活中的点点滴滴","description":"我自是年少，韶华倾覆","author":"佑珈","url":"https://github.com/YoGazz/YoGazz.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-06-03T10:12:52.479Z","updated":"2023-05-26T16:47:29.353Z","comments":false,"path":"/404.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-27T02:52:28.441Z","comments":false,"path":"about/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-26T16:47:29.354Z","comments":false,"path":"books/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-27T03:22:39.413Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/index.html","excerpt":"","text":"Python Django Vue 测试平台 接口自动化 UI自动化 性能测试"},{"title":"友情链接","date":"2024-06-03T10:12:52.481Z","updated":"2023-05-26T16:47:29.354Z","comments":true,"path":"links/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-06-03T10:12:52.482Z","updated":"2023-05-26T16:47:29.354Z","comments":false,"path":"repository/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-06-03T10:12:52.482Z","updated":"2023-05-26T16:47:29.355Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2019-11-10T15:18:30.000Z","updated":"2024-12-03T09:57:51.677Z","comments":true,"path":"photos/index.html","permalink":"https://github.com/YoGazz/YoGazz.github.io/photos/index.html","excerpt":"","text":"图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('../lib/album/ins.js') }, 0) })()"}],"posts":[{"title":"《JAVA基础》：继承","slug":"《JAVA基础》：继承","date":"2025-02-25T06:23:18.000Z","updated":"2025-02-25T06:25:17.470Z","comments":true,"path":"2025/02/25/《JAVA基础》：继承/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2025/02/25/%E3%80%8AJAVA%E5%9F%BA%E7%A1%80%E3%80%8B%EF%BC%9A%E7%BB%A7%E6%89%BF/","excerpt":"一、继承的核心概念1. 什么是继承？ 定义：继承是面向对象编程（OOP）的四大特性之一，允许一个类（子类）基于另一个类（父类）来构建，复用父类的属性和方法。 目的：提高代码复用性，建立类之间的层次关系，支持多态。","text":"一、继承的核心概念1. 什么是继承？ 定义：继承是面向对象编程（OOP）的四大特性之一，允许一个类（子类）基于另一个类（父类）来构建，复用父类的属性和方法。 目的：提高代码复用性，建立类之间的层次关系，支持多态。 2. 继承的语法 使用 extends 关键字实现继承：1234567class ParentClass &#123; // 父类成员&#125;class ChildClass extends ParentClass &#123; // 子类成员&#125; 3. 继承的类型 单继承：Java只支持类的单继承（一个子类只能有一个直接父类）。 多层继承：允许链式继承（例如：A → B → C）。 接口多继承：类可以实现多个接口（implements），接口可以继承多个接口（extends）。 二、继承的成员访问规则1. 可继承的成员 public 和 protected 修饰的成员（字段、方法）。 默认访问权限（无修饰符）的成员，仅在同一包内可继承。 2. 不可继承的成员 private 修饰的成员。 父类的构造器（但可通过super()调用）。 被final修饰的类或方法（final类不可被继承，final方法不可被重写）。 三、方法重写（Override）1. 重写规则 方法签名相同：方法名、参数列表、返回类型（或子类返回类型）必须一致。 访问权限不能更严格：子类方法的访问修饰符应 ≥ 父类方法（例如：父类为protected，子类可为public）。 异常范围不能扩大：子类方法抛出的异常不能比父类更宽泛。 2. @Override注解 显式声明方法重写，编译器会检查是否符合重写规则。 示例：123456789101112class Animal &#123; public void eat() &#123; System.out.println(&quot;Animal eats&quot;); &#125;&#125;class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;Dog eats bones&quot;); &#125;&#125; 四、super关键字的使用1. 调用父类成员 访问父类字段&#x2F;方法：当子类与父类成员同名时，用super.成员名区分。123456789101112class Parent &#123; String name = &quot;Parent&quot;;&#125;class Child extends Parent &#123; String name = &quot;Child&quot;; public void printNames() &#123; System.out.println(super.name); // 输出 Parent System.out.println(this.name); // 输出 Child &#125;&#125; 2. 调用父类构造器 规则：super(...)必须位于子类构造器的第一行。 示例：1234567891011121314class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125;&#125;class Student extends Person &#123; private int grade; public Student(String name, int grade) &#123; super(name); // 调用父类构造器 this.grade = grade; &#125;&#125; 五、继承与多态1. 多态的表现 向上转型（Upcasting）：父类引用指向子类对象。 动态绑定（Dynamic Binding）：运行时根据实际对象类型调用方法。 示例：12Animal myDog = new Dog(); // 向上转型myDog.eat(); // 调用Dog类的eat()方法 2. instanceof运算符 检查对象是否为特定类或其子类的实例。123if (myDog instanceof Dog) &#123; System.out.println(&quot;This is a Dog&quot;);&#125; 六、抽象类与接口1. 抽象类（Abstract Class） 定义：用abstract修饰的类，可以包含抽象方法（无实现）。 用途：为子类提供通用模板，强制子类实现特定方法。 示例：123456789101112abstract class Shape &#123; abstract double area(); // 抽象方法&#125;class Circle extends Shape &#123; private double radius; @Override double area() &#123; return Math.PI * radius * radius; &#125;&#125; 2. 接口（Interface） 定义：用interface定义，默认方法为public abstract（Java 8+支持默认方法和静态方法）。 多继承：类可以实现多个接口。 示例：123456789101112131415interface Flyable &#123; void fly();&#125;interface Swimmable &#123; void swim();&#125;class Duck implements Flyable, Swimmable &#123; @Override public void fly() &#123; /* 实现飞行 */ &#125; @Override public void swim() &#123; /* 实现游泳 */ &#125;&#125; 七、继承的最佳实践 优先使用组合而非继承：除非明确的“is-a”关系，否则用组合（持有其他类的实例）代替继承。 避免过深的继承层次：继承链过长会降低代码可维护性。 使用final限制继承：若类不应被继承，声明为final。 遵循里氏替换原则（LSP）","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"《JAVA基础》：构造器","slug":"《JAVA基础》：构造器","date":"2025-02-25T03:16:31.000Z","updated":"2025-02-25T06:25:12.086Z","comments":true,"path":"2025/02/25/《JAVA基础》：构造器/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2025/02/25/%E3%80%8AJAVA%E5%9F%BA%E7%A1%80%E3%80%8B%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"一、构造器（Constructor）的定义与作用1. 什么是构造器？构造器是类中用于 初始化对象 的特殊方法，在创建对象时通过new关键字自动调用。 2. 核心作用 分配内存：为对象分配堆内存空间。 初始化成员变量：设置对象的初始状态。 执行必要逻辑：如资源加载、参数校验等。","text":"一、构造器（Constructor）的定义与作用1. 什么是构造器？构造器是类中用于 初始化对象 的特殊方法，在创建对象时通过new关键字自动调用。 2. 核心作用 分配内存：为对象分配堆内存空间。 初始化成员变量：设置对象的初始状态。 执行必要逻辑：如资源加载、参数校验等。 二、构造器的基本语法1. 语法规则 名称必须与类名完全相同（区分大小写）。 无返回值类型（连void也不能声明）。 支持重载：一个类可以有多个不同参数的构造器。 2. 默认构造器 如果类中未定义任何构造器，编译器会自动生成一个无参构造器。 示例：123public class User &#123; // 编译器自动生成：public User() &#123;&#125;&#125; 3. 显式定义构造器 无参构造器： 12345public class Car &#123; public Car() &#123; // 初始化逻辑 &#125;&#125; 有参构造器： 123456public class Student &#123; private String name; public Student(String name) &#123; this.name = name; &#125;&#125; 三、构造器的类型与高级用法1. 私有构造器（Singleton模式） 用途：禁止外部通过new创建对象，常用于单例模式或工具类。 示例：123456789101112public class DatabaseConnection &#123; private static DatabaseConnection instance; private DatabaseConnection() &#123;&#125; // 私有构造器 public static DatabaseConnection getInstance() &#123; if (instance == null) &#123; instance = new DatabaseConnection(); &#125; return instance; &#125;&#125; 2. 构造器重载（Overload） 定义：一个类中定义多个参数列表不同的构造器。 示例：123456789101112131415public class Book &#123; private String title; private String author; public Book() &#123;&#125; // 无参构造器 public Book(String title) &#123; this.title = title; &#125; public Book(String title, String author) &#123; this.title = title; this.author = author; &#125;&#125; 3. 构造器链（Constructor Chaining） 用途：通过this()在一个构造器中调用另一个构造器，减少代码冗余。 规则：this()必须放在构造器的第一行。 示例：12345678910111213public class Rectangle &#123; private int width; private int height; public Rectangle() &#123; this(1, 1); // 调用双参构造器 &#125; public Rectangle(int width, int height) &#123; this.width = width; this.height = height; &#125;&#125; 四、构造器与继承1. 核心规则 构造器不可被继承：子类不能直接继承父类的构造器。 必须调用父类构造器：子类构造器的第一行必须通过super(...)显式或隐式调用父类构造器。 2. 隐式调用父类无参构造器 条件：父类存在无参构造器，且子类未显式调用super(...)。 示例：1234567891011class Animal &#123; public Animal() &#123; System.out.println(&quot;Animal构造器&quot;); &#125;&#125;class Dog extends Animal &#123; public Dog() &#123; // 隐式调用super() System.out.println(&quot;Dog构造器&quot;); &#125;&#125; 3. 显式调用父类有参构造器 条件：父类没有无参构造器或需要传递参数。 示例：123456789101112class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125;&#125;class Student extends Person &#123; public Student(String name) &#123; super(name); // 必须显式调用 &#125;&#125; 五、构造器中的异常处理1. 抛出异常 构造器中可以抛出异常，但需确保对象初始化失败时资源被正确释放。 示例：1234567public class FileReader &#123; public FileReader(String path) throws FileNotFoundException &#123; if (!new File(path).exists()) &#123; throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 2. 异常处理建议 避免构造器过于复杂：复杂的初始化逻辑可拆分为独立方法。 使用工厂模式：将可能失败的对象创建逻辑移至工厂方法。 六、构造器与文档生成（Javadoc）1. 文档注释规范 使用/** ... */描述构造器功能和参数。 常用标签：@param, @throws, @see。 2. 示例代码12345678910111213141516171819202122232425/** * 表示一个银行账户的类。 */public class BankAccount &#123; private double balance; /** * 创建一个初始余额为0的账户。 */ public BankAccount() &#123; this(0.0); &#125; /** * 创建一个指定初始余额的账户。 * @param initialBalance 初始余额（必须≥0） * @throws IllegalArgumentException 如果初始余额为负数 */ public BankAccount(double initialBalance) &#123; if (initialBalance &lt; 0) &#123; throw new IllegalArgumentException(&quot;初始余额不能为负数&quot;); &#125; this.balance = initialBalance; &#125;&#125; 3. 生成HTML文档1javadoc -d docs -encoding UTF-8 BankAccount.java 七、构造器的最佳实践 优先使用不可变对象：通过构造器初始化所有字段（结合final关键字）。 避免在构造器中调用可重写方法：可能导致子类状态未初始化。 保持构造器简洁：复杂初始化逻辑应封装到方法中。 使用Builder模式：当构造器参数过多时，提高代码可读性。 八、常见问题与解答Q1：构造器能声明为final或static吗？ 不能：构造器隐式为实例方法，不可用static或final修饰。 Q2：构造器可以同步（synchronized）吗？ 可以，但不推荐，可能导致死锁或性能问题。 Q3：如何实现深拷贝（Deep Copy）？ 通过构造器复制对象及其引用对象的字段：123456789public class Person &#123; private String name; private Address address; public Person(Person other) &#123; this.name = other.name; this.address = new Address(other.address); // 深拷贝 &#125;&#125; 九、总结构造器是Java对象生命周期的起点，掌握其核心规则和高级用法对编写健壮代码至关重要。合理使用构造器重载、链式调用和异常处理，结合Javadoc生成清晰的API文档，将显著提升代码质量和团队协作效率。 将此内容发布到博客时，建议搭配代码高亮插件和流程图工具（如Mermaid）增强可读性。如果需要进一步补充或调整，请随时告知！","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"软件测试中的杀虫剂效应","slug":"软件测试中的杀虫剂效应","date":"2025-01-09T02:42:53.000Z","updated":"2025-01-09T02:45:10.234Z","comments":true,"path":"2025/01/09/软件测试中的杀虫剂效应/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2025/01/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E6%9D%80%E8%99%AB%E5%89%82%E6%95%88%E5%BA%94/","excerpt":"杀虫剂效应（The Pesticide Paradox）是软件测试领域中的一个概念，来源于比喻。它最早由Boris Beizer在其著作《Software Testing Techniques》中提出。这个效应描述了测试过程中一个常见的现象：当你在同样的测试用例和测试策略下进行多次测试时，可能会发现原本的缺陷不再出现，但并不意味着系统没有缺陷，可能只是那些“已知”的缺陷被“杀死”了，而新的缺陷可能未被暴露出来。","text":"杀虫剂效应（The Pesticide Paradox）是软件测试领域中的一个概念，来源于比喻。它最早由Boris Beizer在其著作《Software Testing Techniques》中提出。这个效应描述了测试过程中一个常见的现象：当你在同样的测试用例和测试策略下进行多次测试时，可能会发现原本的缺陷不再出现，但并不意味着系统没有缺陷，可能只是那些“已知”的缺陷被“杀死”了，而新的缺陷可能未被暴露出来。 概念解释： 杀虫剂效应这个比喻借用了杀虫剂的工作原理。假设你每次都使用相同的杀虫剂去对付昆虫。最初，昆虫会被消灭，但如果你总是使用相同的杀虫剂，昆虫可能会对其产生抵抗力，导致效果逐渐减弱，最终无法再有效地消灭它们。 在软件测试中，类似地，如果你重复执行相同的测试用例和测试策略，你可能会发现原来已知的缺陷不再出现。但这并不意味着没有新的缺陷，而是测试策略和测试用例可能已经“失效”或未能触及到新的缺陷类型。 为什么会发生杀虫剂效应？ 测试用例的重复性：重复运行相同的测试用例，特别是如果测试用例没有被更新或没有包含新的边界条件和测试场景，那么只会发现系统中已有的缺陷，而无法暴露新的缺陷。 缺乏创新和多样性：如果没有创新的测试方法或不同的测试视角，测试活动可能会变得单一和僵化，导致未能发现新的问题。 环境变化和新功能：随着软件的不断变化（例如版本更新、需求变更等），老的测试用例可能无法覆盖新加入的功能或修改的代码，导致新缺陷不容易被发现。 测试人员的思维定势：测试人员可能会陷入固有的测试思维和框架中，导致他们忽略了其他潜在的缺陷或未曾考虑过的测试路径。 如何避免杀虫剂效应？ 不断更新测试用例：根据软件的变化、需求的变化，及时更新和添加新的测试用例，确保覆盖新的代码和场景。 多样化测试方法： 黑盒测试与白盒测试结合：除了功能测试，还可以考虑执行结构测试、代码覆盖率测试等。 探索性测试：探索性测试可以帮助发现常规测试用例无法覆盖的缺陷。 压力测试、性能测试、边界条件测试等：这些测试方法有助于发现不同类型的缺陷。 引入自动化测试：自动化测试可以提高测试效率，并确保定期对关键功能进行回归测试，尤其是在大规模系统中，自动化可以帮助更全面地覆盖功能。 交叉验证和多种测试技术：使用不同的工具和技术来进行测试，避免重复的测试模式导致“失效”。例如，结合静态分析工具、动态分析工具、灰盒测试等。 持续的审查和反思：定期回顾测试用例，评估它们的覆盖率和有效性，识别可能的盲点。 小结：杀虫剂效应是一个警示：测试用例和策略不能永远停留在原地。随着软件的发展和变化，测试活动也需要不断创新和调整。单一的测试方法和测试用例可能会导致新缺陷的漏测，进而影响软件质量。因此，软件测试人员需要不断更新测试策略，增加测试的多样性和覆盖面，以更全面地发现潜在的缺陷。 永远不要停止测试，永远不要停止思考，永远不要相信某一种方法或者工具可以帮助你解决所有问题！在这岗位上就不要停止学习新的技术和方法！","categories":[{"name":"测试","slug":"测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"功能测试","slug":"功能测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Java三大特性之一—— 继承","slug":"Java三大特性之一——-继承","date":"2024-12-25T09:31:17.000Z","updated":"2025-01-09T09:35:44.258Z","comments":true,"path":"2024/12/25/Java三大特性之一——-继承/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/25/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"一、为什么要继承","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java三大特性之一—— 封装","slug":"Java三大特性之一——-封装","date":"2024-12-25T08:54:46.000Z","updated":"2025-01-09T09:35:40.910Z","comments":true,"path":"2024/12/25/Java三大特性之一——-封装/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/25/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94-%E5%B0%81%E8%A3%85/","excerpt":"一、什么是封装我们知道在面向对象编程的世界里有三大特征，分别是封装，继承，多态，那我们来了解了解何为封装。 举个例子，拿我们的手机来说，我们所看到的手机外观基本都是非常漂亮的，我们只知道手机该怎么用手机有什么功能，但我们并不知道这些功能这小小的手机是怎么做到的那么小的体积做到有这么多的功能，我们身为使用者，我们是无法知道手机内部是怎么实现这么多功能的，这同时也是手机的制作者想要的，在手机制作者的世界里面，他认为使用者只需要会使用自己放出的功能就足够了，手机内部功能的实现是怎么做到的，使用者没必要知道，使用者会玩手机就足够了。","text":"一、什么是封装我们知道在面向对象编程的世界里有三大特征，分别是封装，继承，多态，那我们来了解了解何为封装。 举个例子，拿我们的手机来说，我们所看到的手机外观基本都是非常漂亮的，我们只知道手机该怎么用手机有什么功能，但我们并不知道这些功能这小小的手机是怎么做到的那么小的体积做到有这么多的功能，我们身为使用者，我们是无法知道手机内部是怎么实现这么多功能的，这同时也是手机的制作者想要的，在手机制作者的世界里面，他认为使用者只需要会使用自己放出的功能就足够了，手机内部功能的实现是怎么做到的，使用者没必要知道，使用者会玩手机就足够了。 这其中就体现了封装，使用者只能使用制作者放出来的东西，使用者不知道手机的内部功能的实现，我想要你知道的你才能知道，我不想要你知道的你就不能知道。封装指的是将数据和操作数据的方法有机结合，同时对外隐藏内部的细节，只暴露必要的接口供其他对象使用。 Java的封装主要是通过类和访问权限来实现的，类可以将数据和操作数据的方法进行有机结合在一起，访问权限用来控制成员变量和成员方法能否在类外进行使用，从而实现对对象内部的实现细节进行隐藏。同时包也是对类，接口等的封装机制的体现，是一种对类和接口很好的组织方式。 封装性的主要目的是保护数据，防止外部的不合理访问和修改，从而提高代码的可维护性和可复用性。 二、访问修饰限定符那如何实现封装呢，这儿就需要使用到访问修饰限定符：public、private、protected、default。通过访问权限的不同来控制方法或者属性能否可以直接在类外使用 2.1、publicpublic是Java里权限最大的，当前类，同一个包中的其他类，不同包的子类，不同包的非子类，都可以访问。可以理解外一个人的外貌，每个人都可以看得见。 2.2、protected protected是访问权限里面第二大的，通常用于被继承的父类，当前类，同一个包中的其他类，不同包的子类。 2.3、defaultdefault并不是一个关键字，当类内的方法或者属性没有被任何访问修饰限定符修饰时，当前方法或者属性被称为包访问权限。可以想象为一个家庭或者一个家族，包访问权限就相当与只有该家庭或者家族内部的人才知道的事情，家庭外或者家族外的人不知道这件事情 2.4、privateprivate是所有权限中最小的，相当于某件事情只有自己知道，其他任何人都不知道。也被称之为私有权限 大多数情况下，成员属性设置为private，成员方法设置为public，将对象的属性隐藏起来，提供开放的接口供给外部使用，这些接口可以操作成员属性。可以操作成员属性的方法一般有两种，一种是set方法，一种是get方法 123456789101112131415161718192021public class Test1 &#123; private int age;//私有 private String name;//私有 public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; set方法可以对成员属性进行赋值 get方法可以取到成员属性的值当成员属性数量多的时候，一个一个的定义set，get方法就会很繁琐并且消耗大量时间，此时编译器就提供了相应的快捷方式，可以一键生成set，get方法 三、包3.1、什么是包在面向对象体系中，提出了软件包的概念，即为了更好的管理类，创建一个包把多个类收集在一起，称之为软件包。有点类似于文件夹，文件夹里面可以存储多个内容，将内容类似的存储在同一个文件夹中，比如说一个班级有男生和女生，男生的信息存储到一号文件夹，女生的信息存储到二号文件夹，此时学生的信息可以更好的进行管理 包是对类和接口等的封装机制的体现 ，是类或者接口的容器，它通过命名空间来区分不同的类，使得即使类名相同，只要它们位于不同的包中就不会发生冲突。这也就意味着在同一个工程里面可以存在名字相同的类 3.2、导入其他包中的类Java本身提供了很多现成的类供我们使用，但在使用之前必须要进行导包，导包需要使用到import关键字，但大多数时候并不需要我们手动导包，编译器会自动导包 1import java.util.*; 导包导包，顾名思义就是将包内我们所需要的类导入当前类中，import java.util.*，并非是将util包内的全部类导入当前类，而是代码需要调用哪个类，编译器就加载对应的util底下的类出来供给JVM使用。 但是这种方式也是有缺陷的，首先就是代码的可读性降低了，其次就是有可能会导致冲突出现。 3.3、自定义包 1、在文件的最上方加上一个package语句声明当前类在哪个包中 2、包名通常会使用公司的域名的颠倒形式（例如：com.bit.www），并且必须要小写字母 3、包名和代码路径相匹配，例如创建com.bit.demo1的包，那么会存在一个对应的路径com&#x2F;bit&#x2F;demo1来存储代码 4、如果一个类没有package语句，那么当前类是存放在默认包底下的，src是默认包。 5、程序在运行的时候是默认在src这个包里面查找可执行程序的。","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"《Java详解》-抽象类","slug":"《Java详解》-抽象类","date":"2024-12-25T07:51:32.000Z","updated":"2024-12-25T08:54:20.408Z","comments":true,"path":"2024/12/25/《Java详解》-抽象类/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/25/%E3%80%8AJava%E8%AF%A6%E8%A7%A3%E3%80%8B-%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"一、概述1.1、什么是抽象类123 在Java中使用最多的就是类，类用于抽象一类事物，是将现实世界的事物通过抽象的方式给描述成为一个类，该类具有这一类事物的属性和行为，通过new关键字可以实例化类，在程序世界中按照类的描述创建一个对象。而当一个类提供的信息不足以实例化一个具体的对象时，或者说当前类的行为不符合具体对象的行为时，我们是不会将当前类实例化对象的，这种类一般被定义为抽象类。举个例子：定义一个宠物类，其中定义成员属性：姓名、年龄、毛色，定义成员行为：吃饭，睡觉等，这个时候我们看宠物类，宠物宠物，是哪一种动物？有点指代不清，并且不同的宠物吃的东西不一样，宠物狗吃狗粮，宠物猫吃猫粮，也就是说宠物类提供的信息不足以描述一个具体的对象，因此我们不会实例化宠物类这个对象，而是将其设置为抽象类。 简而言之，言而简之，当一个类内部定义的成员变量成员方法不足以描述一个具体的对象时，便将该类定义为抽象类","text":"一、概述1.1、什么是抽象类123 在Java中使用最多的就是类，类用于抽象一类事物，是将现实世界的事物通过抽象的方式给描述成为一个类，该类具有这一类事物的属性和行为，通过new关键字可以实例化类，在程序世界中按照类的描述创建一个对象。而当一个类提供的信息不足以实例化一个具体的对象时，或者说当前类的行为不符合具体对象的行为时，我们是不会将当前类实例化对象的，这种类一般被定义为抽象类。举个例子：定义一个宠物类，其中定义成员属性：姓名、年龄、毛色，定义成员行为：吃饭，睡觉等，这个时候我们看宠物类，宠物宠物，是哪一种动物？有点指代不清，并且不同的宠物吃的东西不一样，宠物狗吃狗粮，宠物猫吃猫粮，也就是说宠物类提供的信息不足以描述一个具体的对象，因此我们不会实例化宠物类这个对象，而是将其设置为抽象类。 简而言之，言而简之，当一个类内部定义的成员变量成员方法不足以描述一个具体的对象时，便将该类定义为抽象类 1.2、定义抽象类123在Java中，如果被abstract关键字修饰一个类，那么当前类被称之为抽象类访问修饰符 abstract class 类名&#123; &#125; 1.3、什么是抽象方法1 宠物类不是一个具体的动物，那么其内部的eat（）方法就无法具体实现，具体的eat（）方法只有子类具体的动物对象才可以实现。像这种无法定义具体实现内容的方法我们可以将其设置为抽象方法。 1.4、定义抽象方法 被abstract关键字修饰方法，那么当前方法被称之为抽象方法，抽象方法不需要写方法体，只有方法声明，没有具体的方法实现，没有{ }。 12345678访问修饰符 abstract 返回类型 方法名（参数列表）；public abstract class Animal &#123;//当前Animal类为抽象类 public abstract void eat();//eat（）方法为抽象方法 public abstract void fly();//fly（）方法为抽象方法&#125; 二、特点2.1、抽象类的特点2.1.1、抽象类不可以实例化对象本身就是因为当前类提供的信息不足以描述一个具体的类才将当前类设置为抽象类的，而又将抽象类进行实例化对象，那么得到的结果将得不偿失，抽象类不支持实例化对象，也就是不可以通过new关键字实例化对象。 2.1.2、抽象类必须要被继承抽象类存在的意义本身就是为了被继承，抽象类没有被继承本身抽象类又不可以实例化对象，那么定义当前抽象类来干什么？ 2.1.3、抽象类的子类抽象类的子类必须要重写抽象类当中的全部抽象方法，否则一直爆红，即抽象类当中只要是被abstract关键字修饰的方法都被强制重写。 1234567891011121314// 抽象类public abstract class Animal &#123; // 抽象方法 public abstract void sound(); // 普通方法 public void eat() &#123; System.out.println(&quot;I am eating&quot;); &#125;&#125;class Dog extends Animal&#123; // 实现抽象方法&#125; 有一种方法可以让子类不用重写父类抽象类当中的抽象方法，就是将子类也定义为抽象类，这样当前情况就是抽象类继承抽象类无需重写抽象方法，但是最终还是逃不过重写抽象方法的，该来的还是会来跑不掉的，即便子类是抽象类，那么只要是抽象类结果都是被继承，那么子类抽象类的子类还是要重写抽象方法，而且还是重写父类和父类的父类两个类的抽象方法 这也就意味着抽象类的子类可以有两种选择：1、子类也定义为抽象类2、子类不是抽象类不过最终的结果还是继承普通类，即便子类是抽象类也2逃不过被继承的命运最终还是要重写全部都抽象方法 2.1.4、抽象类的成员抽象类和普通类基本一致，普通类有的抽象类都有，抽象类当中可以定义成员变量，构造器（同样支持重载），普通成员方法，抽象方法。唯一和普通类不同的就是：普通类不可以定义抽象方法，抽象类可以定义抽象方法。 123456789101112131415161718192021222324252627282930313233package ab;public abstract class Animal &#123; protected String name; protected int age; protected String color; // 无参数构造方法 public Animal()&#123; &#125; // 有参数构造方法 public Animal(String name, int age, String color)&#123; this.name = name; this.age = age; this.color = color; &#125; // 普通方法 public void eat()&#123; System.out.println(&quot;动物吃东西&quot;); &#125; // 普通方法 public void sleep()&#123; System.out.println(&quot;动物睡觉&quot;); &#125; // 抽象方法 abstract public void move();&#125; 2.2、抽象方法的特点2.2.1、只能有方法声明，不能有方法体 当方法被abstract关键字修饰时，当前方法就是抽象方法，那么当前方法就不能够有具体的实现细节，将方法头编写完整后直接加上“；”，不可以加{ }，否则系统会爆红。 当方法被关键字abstract修饰时，该方法注定了要被子类重写，因此当前方法没必要再编写具体的实现细节了，语法也不支持编写方法体。 2.2.2、抽象方法只存在于抽象类当中抽象类当中可以不包含抽象方法，但是抽象方法必须存在于抽象类当中，这也就意味着：抽象方法不能存在普通类中。 2.2.3、抽象方法必须要能够被继承抽象类存在的意义就是被继承，抽象方法的存在就是被重写，那么抽象方法必须要满足重写的条件，这也就意味着抽象方法不能够被：static关键字，final关键字，private关键字修饰，被这三个关键字修饰的方法都不支持重写 也就是说：abstract关键字和static关键字，final关键字，private关键字不能共存，就像是this（）和super（）不能同时出现一样。 2.2.4、其子类必须要重写抽象方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package ab;public abstract class Animal &#123; protected String name; protected int age; protected String color; // 无参数构造方法 public Animal()&#123; &#125; // 有参数构造方法 public Animal(String name, int age, String color)&#123; this.name = name; this.age = age; this.color = color; &#125; // 普通方法 public void eat()&#123; System.out.println(&quot;动物吃东西&quot;); &#125; // 普通方法 public void sleep()&#123; System.out.println(&quot;动物睡觉&quot;); &#125; // 抽象方法 abstract public void move();&#125;class Dog extends Animal&#123; public Dog()&#123; &#125; public Dog(String name, int age, String color)&#123; super(name, age, color); &#125; @Override public void move()&#123; System.out.println(&quot;狗跑&quot;); &#125;&#125; 三、应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package ab;import java.sql.SQLOutput;public abstract class Animal &#123; protected String name; protected int age; protected String color; // 无参数构造方法 public Animal()&#123; &#125; // 有参数构造方法 public Animal(String name, int age, String color)&#123; this.name = name; this.age = age; this.color = color; &#125; // 普通方法 public void eat()&#123; System.out.println(&quot;动物吃东西&quot;); &#125; // 普通方法 public void sleep()&#123; System.out.println(&quot;动物睡觉&quot;); &#125; // 抽象方法 abstract public void move();&#125;class Dog extends Animal&#123; public Dog()&#123; &#125; public Dog(String name, int age, String color)&#123; super(name, age, color); &#125; @Override public void move()&#123; System.out.println(&quot;狗跑&quot;); &#125;&#125;class Cat extends Animal&#123; public Cat(String name, int age, String color)&#123; super(name, age, color); &#125; @Override public void move()&#123; System.out.printf(name + &quot;在走\\n&quot;); &#125;&#125; 四、总结 可能会有人说：普通的类也可以定义普通方法，然后其继承的子类也可以重写这些普通方法啊，那这样子抽象类有什么意义？定义成为抽象类然后子类一定要重写抽象方法和子类重写普通父类的普通方法有什么区别吗？这不是脱裤子放屁多此一举吗？ 事实上使用抽象类相当于多了一层编译器的校验，在很多时候，实际的工作不应该由父类来完成，而应该由子类来完成，父类本身的作用就是实现共性的抽取，实现代码的复用，而且大多数情况下父类所提供的信息都是不足以描述一个具体的对象的。那么此时我们一不小心误用了父类，使用普通方法是不会报错的，但是使用抽象类，当父类实例化的时候会提示错误，让我们尽早的发现并解决问题。这也就意味着抽象类本质上是一种预防出错的机制。 很多语法存在的意义都是为了“预防出错” ，例如我们曾经使用fianl关键字，当我们定义变量后，不再对该变量进行更改时，该变量不就相当于是常量吗？但我们使用final关键字时就多了一层预防机制，当我们不小心对该变量进行了修改，编译器就会及时的提醒我们，让我们及时修改错误，避免出现不必要的麻烦。","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"《Java详解》:接口","slug":"《Java详解》-接口","date":"2024-12-24T07:46:31.000Z","updated":"2024-12-25T06:12:56.922Z","comments":true,"path":"2024/12/24/《Java详解》-接口/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/24/%E3%80%8AJava%E8%AF%A6%E8%A7%A3%E3%80%8B-%E6%8E%A5%E5%8F%A3/","excerpt":"一、概述1.1、何为接口12345 我们知道继承普通类和继承抽象类的存在，继承本质上就是实现对共性的抽取同时实现代码的复用，通过对现实事物抽象成为一个类，类内包含这一类事物的属性和行为，继承的存在就是将这一类事物的共同属性和行为抽取出来，当我们在定义属于这一类事物的类时可以直接继承使用，而抽象类的出现是因为父类提供的信息不足以描述一个具体的类，因此将父类定义为抽象类，间接加上了一层校验，防止在代码中不小心使用父类创建并使用父类对象。但是继承也有缺点，继承是对共性的抽取，不同的对象虽然同属一个类但各自都会有不同的个性。 比如：动物类，狗属于动物，鸟属于动物，但是狗会跑，鸟不会，鸟会飞，但是狗不会，这就是两者的个性而非共性，因此其父类动物类就不可以含有行为跑和行为飞。可能有人会说：在定义狗类的时候可以定义自己特有的行为跑，在定义鸟类的时候可以定义鸟类自己特有的行为飞，这种方法确实可以，但是在定义一个鸭子类呢？鸭子可以飞可以跑，难道也要在定义鸭子类的时候再单独定义行为跑行为飞？不免有些繁琐了吧，当定义的类多了，每个类都有单独的自己的行为，但是不同的类之间又有共性，那继承的本质何在？ 因此在这个时候接口就被定义出来了，接口可以理解为是对外提供的一组公共的行为规范标准，只要是当前类实例化的对象符合行为规范标准，那么我们就可以让当前类实现这个接口，举个例子：我们可以定义一个接口，是行为跑的标准，狗这个对象会跑，因此狗这个类就可以实现该接口，再定义一个接口，是行为飞的标准，鸟这个对象会飞，鸭子这个对象也会飞，因此鸟和鸭子这两个类都可以实现该接口。","text":"一、概述1.1、何为接口12345 我们知道继承普通类和继承抽象类的存在，继承本质上就是实现对共性的抽取同时实现代码的复用，通过对现实事物抽象成为一个类，类内包含这一类事物的属性和行为，继承的存在就是将这一类事物的共同属性和行为抽取出来，当我们在定义属于这一类事物的类时可以直接继承使用，而抽象类的出现是因为父类提供的信息不足以描述一个具体的类，因此将父类定义为抽象类，间接加上了一层校验，防止在代码中不小心使用父类创建并使用父类对象。但是继承也有缺点，继承是对共性的抽取，不同的对象虽然同属一个类但各自都会有不同的个性。 比如：动物类，狗属于动物，鸟属于动物，但是狗会跑，鸟不会，鸟会飞，但是狗不会，这就是两者的个性而非共性，因此其父类动物类就不可以含有行为跑和行为飞。可能有人会说：在定义狗类的时候可以定义自己特有的行为跑，在定义鸟类的时候可以定义鸟类自己特有的行为飞，这种方法确实可以，但是在定义一个鸭子类呢？鸭子可以飞可以跑，难道也要在定义鸭子类的时候再单独定义行为跑行为飞？不免有些繁琐了吧，当定义的类多了，每个类都有单独的自己的行为，但是不同的类之间又有共性，那继承的本质何在？ 因此在这个时候接口就被定义出来了，接口可以理解为是对外提供的一组公共的行为规范标准，只要是当前类实例化的对象符合行为规范标准，那么我们就可以让当前类实现这个接口，举个例子：我们可以定义一个接口，是行为跑的标准，狗这个对象会跑，因此狗这个类就可以实现该接口，再定义一个接口，是行为飞的标准，鸟这个对象会飞，鸭子这个对象也会飞，因此鸟和鸭子这两个类都可以实现该接口。 12345678910111213// 动物类public class Animal &#123; protected String name; public Animal(String name) &#123; this.name = name; &#125; public String getName()&#123; return name; &#125;&#125; 1234567// 接口游package duixiang;public interface Iswim &#123; void swim();&#125; 1234567// 接口跑package duixiang;public interface IRun &#123; void run();&#125; 12345678910111213141516171819// 鸭子类实现接口跑和游package duixiang;public class Duck extends Animal implements Iswim, IRun &#123; public Duck(String name)&#123; super(name); &#125; @Override public void swim()&#123; System.out.printf(name + &quot;在游&quot;); &#125; @Override public void run()&#123; System.out.printf(name + &quot;在跑&quot;); &#125;&#125; 1234567891011121314package duixiang;public class Dog extends Animal implements IRun&#123; public Dog(String name)&#123; // 调用父类的构造方法 super(name); &#125; @Override public void run()&#123; System.out.printf(name + &quot;在跑&quot;); &#125;&#125; 当鸭子类实现了接口跑和接口游之后，鸭子类就包含有了行为跑和行为游，狗类实现了接口跑后，狗类就包含有了行为跑。因此接口技术用于描述类具有什么功能，但是接口中并不给出具体的实现，当某个类需要使用当前接口时再去实现接口中的方法，类需要遵从接口中描述的统一标准进行定义，所以接口就是统一的行为规范标准，接口在实现的时候，只需要符合行为规范标准就可以通用。在Java中，接口可以看作是多个类的公共规范，是一种引用类型。 1.2、接口的定义接口的定义和类的定义相似，类的定义需要所以class关键字，而接口的定义需要使用interface关键字，而接口的定义方式就是将类的定义关键字class换成interface关键字即可。 1234访问修饰符 class 类名访问修饰符 interface 接口名 接口的创建和类的创建一样，都是通过右键单击src生成的 二、特点2.1、接口的成员变量接口的成员属性默认是被 public static final修饰的，主要就是意味着在接口中定义的成员属性默认是静态常量。 1234561、当接口的变量被privateprotected访问修饰符修饰时编译器直接爆红 2、当变量没有任何修饰符修饰的时候，在实现类当中不可以对其进行修改 3、当变量只被pulic修饰的时候，在实现类当中也不可以对其进行修改 4、当变量被public static final 修饰时，三个关键字都是灰色的，说明变量是默认被这三个关键字修饰的，因此这三个关键字可以不用编写，编译器 会自动加上的 2.2、接口的成员方法接口的成员方法默认是被publicabstract修饰的，也就是说不可以有具体的实现内容，这也就意味着接口中的成员方法默认是抽象 方法。 123456public interface ITest &#123; public int func()&#123; &#125;; public int func1();&#125; 如上，方法func（）有{}，代表有具体的实现，但是不符合抽象方法的语法，编译器直接爆红；方法func1（）编写完参数列表后直接引号结尾，符合抽象方法的语法。 12345public interface ITest &#123; public abstract void func1(); public void func2(); void func3();&#125; 我们可以发现被publicabstract修饰的方法和什么的不修饰的方法都是一样的，并且func（）方法的关键字public abstract是灰色的，说明方法默认是被这两个关键字修饰的，即便程序员没有编写，编译器也会自动添加的。 也就是说在接口当中不可以有普通方法的实现，一旦实现编译器直接爆红，但是一定要实现普通方法也不是不可以，只需要将普通方法修饰成为静态方法即可： 12345678910111213public interface ITest &#123; public abstract void func1(); public void func2(); void func3(); public static void func4()&#123; System.out.println(&quot;func4&quot;); &#125;; public static String func5()&#123; return &quot;func5&quot;; &#125;;&#125; 或者是让当前方法被default修饰： 123456789public interface ITest1 &#123; public static void func4()&#123; System.out.println(&quot;func4&quot;); &#125;; public default void func6()&#123; System.out.println(&quot;func6&quot;); &#125;;&#125; 2.3、接口中不可以含有构造器和代码块123456789101112131415public interface ITest2 &#123; // 构造方法 public interface ()&#123; &#125;; // 代码块 &#123; &#125; // 静态代码 static &#123; &#125;&#125; 因此在接口中定义的属性都只能够通过就地初始化进行初始化，无法通过构造器进行初始化 2.4、接口不可以实例化对象 接口和抽象类一样，都是引用型数据类型，但都不可以通过关键字new进行实例化对象的，本质上两者提供的信息都不足以描述一个具体的对象，就没有必要实例化对象，如果误把抽象类或者接口进行实例化对象并使用了，那么编译器会直接爆红提示错误，因此接口也含有和抽象类一样的校验功能。 2.5、接口和类之间使用implements关键字进行连接类和类之间是继承关系，类和接口之间是实现关系。子类继承父类，类实现接口 123456789public interface Itest &#123; public abstract void func(); public void func1(); void func3();&#125;class teat implements Itest &#123; &#125; 需要注意的是，接口和抽象类一样里面都包含有抽象方法，这也就意味着当类实现了接口后，需要重写接口里面全部的抽象方法。 12345678910111213141516171819202122232425262728293031package jiekou;public interface ITest &#123; public abstract void func1(); public void func2(); void func3();&#125;class Main implements ITest&#123; public static void main(String[] args) &#123; Main m = new Main(); m.func1(); &#125; @Override public void func1()&#123; System.out.println(&quot;func1&quot;); &#125; @Override public void func2()&#123; System.out.println(&quot;func2&quot;); &#125; @Override public void func3()&#123; System.out.println(&quot;func3&quot;); &#125;&#125; 2.6、当类在重写接口中的方法时，不可以使用默认的访问权限重写的规则为： 1、方法名，返回类型，参数列表要一致 2、重写必须要在继承机制下 3、重写方法的访问权限必须要大于等于被重写方法的访问权限 在接口中的方法默认是被public abstract修饰的，那么类当中重写方法的访问权限就必须要大于等于public。 2.7、接口虽然不是类，但是接口通过编译了之后也会生成class文件2.8、如果类没有实现接口当中的全部抽象方法，那么该类必须要设置为抽象类如果类当中没有实现接口中的全部抽象方法时，编译器会爆红，直到全部实现之后才不会爆红，因此和抽象类一样，继承抽象类和实现接口的类只有两种选择：要么老老实实全部实现，要么就将当前类设置为抽象类。不过该来的还是回来，抽象类存在的意义就是为了被继承，也就是说即便设、置为抽象类了，该抽象类后面也是会被继承的，那么还是逃不过实现抽象方法的结果 12345678910111213141516171819202122232425262728public interface Itest &#123; public abstract void func(); public void func1(); void func3();&#125;abstract class teat implements Itest &#123;&#125;class test extends teat &#123; @Override public void func() &#123; &#125; @Override public void func1() &#123; &#125; @Override public void func3() &#123; &#125;&#125; 2.9、类支持实现多个接口在Java中类不支持多继承，类与类之间是单继承，一个类只能有一个父类，但是在Java中，一个类可以实现多个接口。 12345678910111213141516public class Duck extends Animal implements Iswim , IRun&#123; public Duck(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(name + &quot;在跑&quot;); &#125; @Override public void wim() &#123; System.out.println(name + &quot;在游&quot;); &#125;&#125; 如代码，Duck类继承了Animal类并实现了接口Iswin和接口IRun两个接口 2.10、接口之间支持多继承类与类之间支持继承，类与接口之间支持实现，接口与接口之间也支持继承，并且支持多继承，也就是使用接口可以达到多继承的效果。接口可以继承接口，从而达到复用的效果，使用extends关键字。 通过接口继承创建一个新的接口IAmphibious表示“两栖的”，此时如果实现该借口，那么当前类就必须要重写IRun接口和Iswin接口的全部抽象方法。如此一来间接的实现了多继承的效果，也达到了IRun接口和Iswin接口中的方法代码复用，减少了程序员编写重复代码的时间。 三、应用3.1、实现多个接口1234567package jiekoutest;// 接口飞public interface Ifly &#123; void fly();&#125; 123456package jiekoutest;// 接口跑public interface IRun &#123; void run();&#125; 1234567package jiekoutest;// 接口两栖public interface Isecdwe extends IRun, ISwim&#123;&#125; 123456package jiekoutest;public interface ISwim &#123; void swim();&#125; 12345package jiekoutest;// 接口三栖public interface ITiHabitat extends ISwim, IRun, Ifly&#123;&#125; 1234567891011121314package jiekoutest;public abstract class Animal &#123; protected String name; protected int age; public abstract void eat(); public Animal(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 123456789101112131415161718package jiekoutest;// 鸟类public class Bird extends Animal implements Ifly&#123; public Bird(String name, int age)&#123; super(name, age); &#125; public void eat()&#123; System.out.println(name + &quot;在吃虫子&quot;); &#125; @Override public void fly()&#123; System.out.println(name + &quot;在飞&quot;); &#125;&#125; 123456789101112131415161718192021222324package jiekoutest;// 狗类public class Dog extends Animal implements Isecdwe&#123; public Dog(String name, int age)&#123; super(name, age); &#125; @Override public void eat()&#123; System.out.println(name + &quot;在吃骨头&quot;); &#125; @Override public void run()&#123; System.out.println(name + &quot;在跑&quot;); &#125; @Override public void swim()&#123; System.out.println(name + &quot;在游泳&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728package jiekoutest;public class Duck extends Animal implements ITiHabitat&#123; public Duck(String name,int age)&#123; super(name,age); &#125; @Override public void eat()&#123; System.out.println(name + &quot;在吃小鱼&quot;); &#125; @Override public void run()&#123; System.out.println(name + &quot;在走&quot;); &#125; @Override public void swim()&#123; System.out.println(name + &quot;在游泳&quot;); &#125; @Override public void fly()&#123; System.out.println(name + &quot;在飞&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package jiekoutest;public class Main &#123; public static void funcrun(IRun irun)&#123; irun.run(); &#125; public static void funcswim(ISwim iswim)&#123; iswim.swim(); &#125; public static void funcfly(Ifly ifly)&#123; ifly.fly(); &#125; public static void funcer(Isecdwe isecdwe)&#123; isecdwe.run(); isecdwe.swim(); &#125; public static void functih(ITiHabitat itiHabitat)&#123; itiHabitat.run(); itiHabitat.swim(); itiHabitat.fly(); &#125; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;旺财&quot;, 3); dog.run(); funcrun(dog); &#125;&#125; 在func方法内部，方法不关心传递过来的对象是什么对象，方法内部只关心该对象是否有实现当前接口，然后当前对象实现了接口，那么成功编译，如果没有实现当前接口，那么编译报错。 父类：对子类共性的抽取接口：对象的行为标准规范，也可以说是某种功能特性 不是所有的动物都会飞会游，这些行为不是动物的共性，因此无法将这些行为定义到父类当中，最优解就是将这些非共有行为设置为接口，只要是符合接口定义的行为规范准则的动物都可以实现接口，此时就解决了非共性问题。可以简单理解为：父类是共有特性，接口是独有特性 Java面向对象编程中最常见的用法：一个类继承一个父类，同时实现多个接口。这样设计有什么好处呢？可以让程序员忘记类型，有了接口之后，类的使用者就不需要再关心具体类型，只需要关心当前类是否有实现某个接口，具备某种能力。 在func方法中，参数列表设置为接口类型，则该方法就不需要关注传递过来的对象是否是动物，只要该对象的类型实现了该接口，就可以使用该方法，也就是说重新定义一个机器人类，只要机器人类实现了该接口，则机器人类就可以调用该方法。 3.2、给对象排序当我们实例化了大量的学生对象，此时需要对学生对象进行排序，我们可以定义一个学生类型的数组，并将顺序存储进入数组中。我们知道Java有定义一个冒泡排序的方法sort（），我们能否直接通过该方法进行对学生对象的排序呢？","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"《JAVA基础》：面向对象","slug":"《JAVA基础》：面向对象-2","date":"2024-12-24T02:30:46.000Z","updated":"2024-12-24T01:51:08.169Z","comments":true,"path":"2024/12/24/《JAVA基础》：面向对象-2/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/24/%E3%80%8AJAVA%E5%9F%BA%E7%A1%80%E3%80%8B%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/","excerpt":"OOP 三大特征封装性**封装性的设计思想：隐藏对象内部的复杂性，只对外公开简单的接口。**便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。 程序设计追求&quot;高内聚，低耦合&quot;： 高内聚：类的内部数据操作细节自己完成，不允许外部干涉。 低耦合：仅对外暴露少量的方法用于使用。","text":"OOP 三大特征封装性**封装性的设计思想：隐藏对象内部的复杂性，只对外公开简单的接口。**便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。 程序设计追求&quot;高内聚，低耦合&quot;： 高内聚：类的内部数据操作细节自己完成，不允许外部干涉。 低耦合：仅对外暴露少量的方法用于使用。 Java 中通过将对象的属性声明为私有的（private），再提供公共的（public）方法 —&gt; getXxx()和setXxx()，来实现对属性的操作，并以此达到信息的封装和隐藏的目的： 隐藏一个类中不需要对外提供的实现细节。 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作。 便于修改，增强代码的可维护性。 封装性的体现：属性私有、方法私有、构造器私有（如单例模式）等。 封装性的体现，需要权限修饰符的配合。 继承性如果多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么这多个类无需再定义这些属性和行为，只要继承那个抽出来的类即可。 此处的多个类称为子类（派生类、subclass），单独的这个类称为父类（基类、超类、superclass）。可以理解为：”子类 is a 父类”。 类继承语法格式： 123class SubClass extends SuperClass &#123; &#125; 继承性的作用： 继承的出现减少了代码冗余，提高了代码的复用性。 继承的出现，更有利于功能的扩展。 继承的出现，让类与类之间产生了关系，提供了多态的前提。 继承性的特点： 子类继承了父类，就继承了父类中声明的所有属性和方法。特别的，父类中声明为 private 的属性和方法，子类继承父类以后，仍然认为子类获取了父类中私有的结构，只是因为封装性的影响，使得子类的实例不能直接调用父类的这些私有的结构而已（事实上，父类的实例，也不能直接调用这些私有的结构）。 在子类中，可以使用父类中定义的方法和属性，也可以声明创建子类特有的属性和方法，以实现功能的扩展。 在 Java 中，继承的关键字用的是extends，即子类不是父类的子集，而是对父类的扩展。 继承性的规则： 子类不能直接访问父类中私有的（private）的成员变量和方法。 Java 只支持单继承和多层继承，不允许多重继承。 一个子类只能有一个父类。 一个父类可以派生出多个子类。 此处强调的是 Java 类的单继承性，Java 中，接口是可以多继承的。 子类和父类是一个相对概念。子类直接继承的父类，称为直接父类，间接继承的父类，称为间接父类。 子类继承父类后，就获取了直接父类及所有间接父类中声明的属性和方法。 所有的 Java 类（除 java.lang.Object 类之外），都直接或间接继承 java.lang.Object。即，Java 中所有的类，都是 Object 类的子类。 多态性多态性，也叫对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）。 一个变量只能有一种确定的数据类型。 一个引用类型变量可能指向（引用）多种不同类型的对象。 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型（upcasting）。 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法： 多态的使用： 虚拟方法调用。 有了对象的多态性以后，在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类中重写的父类的方法。 编译，看左边；运行，看右边。 Java 引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。 若编译时类型和运行时类型不一致，就出现了对象的多态性。 多态情况下，看左边：看的是父类的引用（父类中不具备子类特有的方法），看右边：看的是子类的对象（实际运行的是子类重写父类的方法）。 对象的多态性，只适用于方法，不适用于属性。对于属性，编译期和运行期，看的都是左边，即都是父类中声明的那个属性。 成员方法：编译时，要查看引用变量所声明的类中是否有所调用的方法。运行时，调用实际 new 的对象所属的类中的重写方法。 成员变量：不具备多态性，只看引用变量所声明的类。 子类继承父类： 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。 编译，看左边；运行，看右边。 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。 编译，运行，都看左边。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Person &#123; String name; int age; public void eat() &#123; System.out.println(&quot;人吃饭&quot;); &#125; public void walk() &#123; System.out.println(&quot;人走路&quot;); &#125; public static void main(String[] args) &#123; // 对象的多态性：父类的引用指向子类的对象 Person person = new Man(); // 多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写的父类的方法---&gt;虚拟方法调用 // 编译期，只能调用父类 Person 类中的方法；运行期，执行的是子类 Man 类中的方法 person.eat(); person.walk(); // 不能调用子类特有的属性或方法，因为编译时, person 是 Person 类型，而 Person 类中没有子类的这个特有属性或方法 // 有了对象的多态性以后，内存中实际上是加载了子类特有的属性或方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类中特有的属性和方法不能调用 // person.isSmoking = true; // person.earnMoney(); System.out.println(&quot;*********************************&quot;) // 如何才能使用子类特有的属性和方法？ // 向下转型：使用强制类型转换符 Man man = (Man) person; man.isSmoking = true; man.earnMoney(); // 使用强转时，可能出现 java.lang.ClassCastException 异常 Woman woman = (Woman) person; woman.goShopping(); &#125;&#125;输出结果：父类空参构造器子类空参构造器男人多吃肉，长肌肉男人霸气的走路*********************************男人负责挣钱养家public class Man extends Person &#123; boolean isSmoking; public void earnMoney() &#123; System.out.println(&quot;男人负责挣钱养家&quot;); &#125; @Override public void eat() &#123; System.out.println(&quot;男人多吃肉，长肌肉&quot;); &#125; @Override public void walk() &#123; System.out.println(&quot;男人霸气的走路&quot;); &#125;&#125; 示例二： 1234567891011121314151617181920212223242526272829public class FieldMethodTest &#123; public static void main(String[] args) &#123; Sub s = new Sub(); System.out.println(s.count);// 20 s.display();// 20 Base b = s; // 对于引用数据，== 比较的是两个引用数据类型变量的地址值 System.out.println(b == s);// true System.out.println(b.count);// 10 b.display();// 20 &#125;&#125; class Base &#123; int count = 10; public void display() &#123; System.out.println(this.count); &#125;&#125; class Sub extends Base &#123; int count = 20; @Override public void display() &#123; System.out.println(this.count); &#125;&#125; 示例三： 123456789101112131415161718192021222324252627public class InterviewTest1 &#123; public static void main(String[] args) &#123; Base base = new Sub(); base.add(1, 2, 3);// sub_1 Sub s = (Sub) base; s.add(1, 2, 3);// sub_2 &#125;&#125; class Base &#123; public void add(int a, int... arr) &#123; System.out.println(&quot;base&quot;); &#125;&#125; class Sub extends Base &#123; @Override public void add(int a, int[] arr) &#123; System.out.println(&quot;sub_1&quot;); &#125; // 这个方法没有重写，在 Base 类中不存在这样声明的方法，也就没有多态，所以 base.add(1, 2, 3) 方法输出 sub_1 public void add(int a, int b, int c) &#123; System.out.println(&quot;sub_2&quot;); &#125;&#125; 多态性的使用前提： 有类的继承关系。 有方法的重写。 如果没有以上两个前提，就不存在多态。 多态性的优点： 提高了代码的通用性，常称作接口重用。 方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AnimalTest &#123; // 多态的使用：传入的是 Animal 对象，但实际传入的可以是 Animal 的子类 public void func(Animal animal) &#123; animal.eat(); animal.shout(); &#125; public static void main(String[] args) &#123; AnimalTest animalTest = new AnimalTest(); animalTest.func(new Dog()); animalTest.func(new Cat()); &#125;&#125; class Animal &#123; public void eat() &#123; System.out.println(&quot;动物：进食&quot;); &#125; public void shout() &#123; System.out.println(&quot;动物：叫&quot;); &#125;&#125; class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; @Override public void shout() &#123; System.out.println(&quot;汪！汪！汪！&quot;); &#125;&#125; class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; @Override public void shout() &#123; System.out.println(&quot;喵！喵！喵！&quot;); &#125;&#125; // 举例二class Order &#123; // 此方法可以传入任意对象，而不需要每个特定对象都创建一次 method() 方法 public void method(Object object) &#123; // 方法体 &#125;&#125; 抽象类、接口的使用：抽象类和接口不能实例化，它们的使用也体现了多态。 虚拟方法调用： 正常的方法调用： 1234Person e = new Person();e.getInfo();Student e = new Student();e.getInfo(); 虚拟方法调用（多态情况下）：子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为**虚拟方法**，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。 12Person e = new Student();e.getInfo();// 调用 Student 类的 getInfo() 方法 编译时类型和运行时类型：上面代码中，编译时 e 为 Person 类型，而方法的调用是在运行时确定的，所以调用的是 Student 类的 getInfo() 方法 —&gt; **动态绑定**。 重写是多态，重载不是。 示例： 多态是编译时行为还是运行时行为? **多态是运行时行为**，证明方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class InterviewTest &#123; public static Animal getInstance(int key) &#123; switch (key) &#123; case 0: return new Cat(); case 1: return new Dog(); default: return new Sheep(); &#125; &#125; public static void main(String[] args) &#123; // 因为 key 需要在运行时才能得到值，编译期时无法判断 getInstance() 方法输出什么 int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); &#125;&#125; class Animal &#123; protected void eat() &#123; System.out.println(&quot;animal eat food&quot;); &#125;&#125; class Cat extends Animal &#123; @Override protected void eat() &#123; System.out.println(&quot;cat eat fish&quot;); &#125;&#125; class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;Dog eat bone&quot;); &#125;&#125; class Sheep extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;Sheep eat grass&quot;); &#125;&#125; 抽象性抽象类和抽象方法随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。 抽象类应用：抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。 **abstract**： abstract：抽象的。 abstract 可以用来修饰：类、方法。 abstract 不能修饰变量、代码块、构造器。 abstract 不能修饰私有方法、静态方法、final 的方法、final 的类。 abstract 修饰类：抽象类。 抽象类不能实例化。 抽象类中一定有构造器，便于子类实例化时调用，但抽象类本身不能使用构造器。 开发中，会提供抽象类的子类，让子类对象实例化，完成相关操作。 abstract 修饰方法：抽象方法。 抽象方法只有方法声明，没有方法体，以分号结束。比如：public abstract void talk();。 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。 若子类重写了父类（不仅包括直接父类，也包括间接父类）中的所有的抽象方法后，此子类方可实例化；若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用 abstract 修饰。 抽象类的匿名子类对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Test &#123; public static void method(Student student) &#123; &#125; public static void method1(Person person) &#123; person.eat(); &#125; public static void main(String[] args) &#123; // 匿名对象 method(new Student()); // 1. 创建非匿名类的非匿名的对象 Worker worker = new Worker(); method1(worker); // 2. 创建非匿名类的匿名的对象 method1(new Worker()); // 3. 创建匿名子类的非匿名的对象：p Person p = new Person() &#123; @Override public void eat() &#123; // 重写方法体 System.out.println(&quot;...&quot;); &#125; &#125;; method1(p); // 4. 创建匿名子类的匿名对象 method1(new Person() &#123; @Override public void eat() &#123; // 重写方法体 System.out.println(&quot;,,,&quot;); &#125; &#125;); &#125;&#125; abstract class Person &#123; public abstract void eat();&#125; class Student &#123; &#125; class Worker extends Person &#123; @Override public void eat() &#123; // 重写方法体 System.out.println(&quot;、、、&quot;); &#125;&#125; 接口（interface）一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is - a 的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3 机、手机、数码相机、移动硬盘等都支持 USB 连接。 接口就是规范，定义的是一组规则，体现了现实世界中 “如果你是&#x2F;要…则必须能…” 的思想。继承是一个 “是不是” 的关系，而接口实现则是 “能不能” 的关系。 接口的本质是契约，标准，规范，就像我们的法律一样，制定好后大家都要遵守。 接口的定义： 接口使用interface定义。 接口中不能定义构造器，意味着接口不可以实例化。 如何定义接口中的成员： JDK 7 及以前：只能定义全局常量和抽象方法。 全局常量：接口中的所有成员变量都默认由 public static final 修饰的。书写时，可以省略，但含义不变，常量不能被更改。 抽象方法：接口中的所有抽象方法都默认由 public abstract 修饰的。 JDK 8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法。 静态方法：使用static关键字修饰，默认为 public 的。 只能通过接口直接调用，并执行其方法体。 默认方法：使用default关键字修饰，默认为 public 的。 可以通过实现类的对象来调用，如果实现类重写了接口中的默认方法，调用时，执行的是重写后的方法。 如果子类（或实现类）继承的父类和实现的接口中，声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下， 默认调用的是父类中的同名同参数的方法 —&gt; 类优先原则。如果重写了，调用子类重写的方法。 如果实现类实现了多个接口，而多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，编译不通过 —&gt; 接口冲突。如果要避免接口冲突，则在实现类中，必须重写此方法。 在子类（或实现类）的方法中，使用super.方法名调用父类的方法，使用接口名.super.方法名调用接口中的方法。 示例： 1234567891011121314151617181920212223public interface InterfaceA &#123; // 静态方法 static void method1() &#123; System.out.println(&quot;接口A：静态方法1&quot;); &#125; // 默认方法 default void method2() &#123; System.out.println(&quot;接口A：默认方法2&quot;); &#125; default void method3() &#123; System.out.println(&quot;接口A：默认方法3&quot;); &#125; default void method4() &#123; System.out.println(&quot;接口A：默认方法4&quot;); &#125; default void method5() &#123; System.out.println(&quot;接口A：默认方法5&quot;); &#125;&#125; 12345public interface InterfaceB &#123; default void method5() &#123; System.out.println(&quot;接口B：默认方法5&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SubClassTest &#123; public static void main(String[] args) &#123; // 1. 静态方法 InterfaceA.method1(); SubClass subClass = new SubClass(); // 2. 默认方法 subClass.method2(); // 3. 重写的默认方法 subClass.method3(); // 4. 调用的是父类中的 method4() subClass.method4(); &#125;&#125; class SuperClass &#123; public void method4() &#123; System.out.println(&quot;父类：方法4&quot;); &#125;&#125; class SubClass extends SuperClass implements InterfaceA, InterfaceB &#123; // 重写接口 InterfaceA 中的 method3() @Override public void method3() &#123; System.out.println(&quot;实现类：方法3&quot;); &#125; // 重写了父类 SuperClass 的 method4() @Override public void method4() &#123; System.out.println(&quot;实现类：方法4&quot;); &#125; // InterfaceA 和 InterfaceB 声明了同名同参的 method5()，SubClass 中必须重写此方法，否则接口冲突，编译不通过 // 如果继承的父类 SuperClass 中也声明了同名同参的 method5()，则不会出现接口冲突 @Override public void method5() &#123; System.out.println(&quot;实现类：方法5&quot;); &#125; public void myMethod() &#123; method2();// InterfaceA 的method2() method3();// 重写的 InterfaceA 的 method3() InterfaceA.super.method3();// InterfaceA 的 method3() method4();// 重写的 SuperClass 的 method4() super.method4();// 父类 SuperClass 的 method4() InterfaceA.super.method5();// InterfaceA 的 method5() InterfaceB.super.method5();// InterfaceB 的 method5() &#125;&#125; 接口的使用： Java 中，接口和类是并列的两个结构，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类。 Java 中，接口都通过让类去实现的方式（implements）来使用（面向接口编程）。 如果实现类覆盖了接口中（包括直接接口和间接接口）的所有抽象方法，则此实现类可以实例化。如果实现类没有覆盖接口（包括直接接口和间接接口）中所有的抽象方法，则此实现类仍为一个抽象类。 12345678910111213141516171819202122interface MyInterface&#123; String s = &quot;MyInterface&quot;; public void absM1();&#125; interface SubInterface extends MyInterface&#123; public void absM2();&#125; // 实现类 SubAdapter 必须给出接口 SubInterface 以及父接口 MyInterface 中所有方法的实现// 否则，SubAdapter 仍需声明为 abstract 的public class SubAdapter implements SubInterface&#123; @Override public void absM1()&#123; System.out.println(&quot;absM1&quot;); &#125; @Override public void absM2()&#123; System.out.println(&quot;absM2&quot;); &#125;&#125; Java 类可以实现多个接口，弥补了 Java 类单继承性的局限性。 格式：class SubClass extends SuperClass implements InterfaceA, InterfaceB, InterfaceC &#123;&#125; 接口与接口之间可以继承，而且可以多继承，使用关键字 extends，但接口不能多实现接口。 格式：interface InterfaceA extends InterfaceB, InterfaceC &#123;&#125; 与继承关系类似，接口与实现类之间体现了多态性。 接口，实际上可以看作是一种规范。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class InterfaceTest &#123; public static void main(String[] args) &#123; System.out.println(Flyable.MAX_SPEED); System.out.println(Flyable.MIN_SPEED); Plane plane = new Plane(); plane.fly(); &#125;&#125; interface Flyable &#123; // 全局常量，可以省略 public static final int MAX_SPEED = 7900;// 第一宇宙速度 int MIN_SPEED = 1; // 抽象方法，可以省略 public abstract public abstract void fly(); void stop();&#125; interface Attackable &#123; void attack();&#125; // 全部实现接口中的方法，可以实例化class Plane implements Flyable &#123; @Override public void fly() &#123; System.out.println(&quot;飞机起飞&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;飞机降落&quot;); &#125;&#125; // 未全部实现接口中的方法，仍是一个抽象类abstract class Kite implements Flyable &#123; @Override public void fly() &#123; System.out.println(&quot;风筝在飞&quot;); &#125;&#125; // 实现多个接口class Bullet implements Flyable, Attackable &#123; @Override public void fly() &#123; System.out.println(&quot;子弹起飞&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;子弹停止&quot;); &#125; @Override public void attack() &#123; System.out.println(&quot;子弹具有攻击性&quot;); &#125;&#125; 面试题： 抽象类与接口有哪些异同？ 接口能继承接口； 抽象类能继承接口（如不完全实现接口方法的类，还是抽象类）； 抽象类能继承非抽象类（如抽象类的父类 Object）。 排错： 因为接口 A 和父类 B 是并列的，所以需要明确变量 x 的所属，如果 A 是 B 的父类，那么在 C 中就近原则，x 会认为是 B 的属性： 1234567891011121314151617181920212223interface A &#123; int x = 0; int x1 = 2;&#125; class B &#123; int x = 1; int x2 = 3;&#125; class C extends B implements A &#123; public void pX() &#123; System.out.println(x);// error: Reference to &#x27;x&#x27; is ambiguous, both &#x27;B.x&#x27; and &#x27;A.x&#x27; match // System.out.println(A.x);// 0 // System.out.println(super.x);// 1 System.out.println(x1);// 2 System.out.println(x2);// 3 &#125; public static void main(String[] args) &#123; new C().pX(); &#125;&#125; 接口中的所有成员变量都默认是 public static final 的，不能在实现类中被重写： 123456789101112131415161718192021222324252627282930interface Playable &#123; void play();&#125; interface Bounceable &#123; void play();&#125; interface Rollable extends Playable, Bounceable &#123; Ball BALL = new Ball(&quot;PingPang&quot;);&#125; class Ball implements Rollable &#123; private String name; public String getName() &#123; return name; &#125; public Ball(String name) &#123; this.name = name; &#125; // play() 方法被认为是即重写了接口 Playable，又重写了接口 Bounceable @Override public void play() &#123; BALL = new Ball(&quot;Football&quot;);// error: Cannot assign a value to final variable &#x27;BALL&#x27; System.out.println(BALL.getName()); &#125;&#125; 接口匿名实现类的对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class InterfaceTest &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); // 1. 创建接口的非匿名实现类的非匿名对象 Flash flash = new Flash(); computer.transferData(flash); // 2. 创建接口的非匿名实现类的匿名对象 computer.transferData(new Printer()); // 3. 创建接口的匿名实现类的非匿名对象 USB phone = new USB() &#123; @Override public void start() &#123; System.out.println(&quot;手机开始工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;手机停止工作&quot;); &#125; &#125;; computer.transferData(phone); // 4. 创建接口的匿名实现类的匿名对象 computer.transferData(new USB() &#123; @Override public void start() &#123; System.out.println(&quot;mp3开始工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;mp3停止工作&quot;); &#125; &#125;); &#125;&#125; class Computer &#123; public void transferData(USB usb) &#123; usb.start(); transferDetails(); usb.stop(); &#125; private void transferDetails() &#123; System.out.println(&quot;具体传输数据的细节&quot;); &#125;&#125; interface USB &#123; void start(); void stop();&#125; class Flash implements USB &#123; @Override public void start() &#123; System.out.println(&quot;U盘开启工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;U盘停止工作&quot;); &#125;&#125; class Printer implements USB &#123; @Override public void start() &#123; System.out.println(&quot;打印机开启工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;打印机停止工作&quot;); &#125;&#125; 子类对象实例化过程 从结果上看： 子类继承父类之后，就获取了父类中声明的属性和方法。（继承性） 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上看： 当通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了 java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才能够进行调用。 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终只创建了一个对象，即为 new 出来的子类对象。 示例：从输出结果可以看出，在创建 Man 的实例时，先进入了父类的空参构造器，然后执行子类的空参构造器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person &#123; String name; int age; public Person() &#123; System.out.println(&quot;父类空参构造器&quot;); &#125; public void eat() &#123; System.out.println(&quot;人吃饭&quot;); &#125; public void walk() &#123; System.out.println(&quot;人走路&quot;); &#125; public static void main(String[] args) &#123; Person person = new Man(); person.eat(); person.walk(); &#125;&#125; class Man extends Person &#123; boolean isSmoking; public Man() &#123; System.out.println(&quot;子类空参构造器&quot;); &#125; public void earnMoney() &#123; System.out.println(&quot;男人负责挣钱养家&quot;); &#125; @Override public void eat() &#123; System.out.println(&quot;男人多吃肉，长肌肉&quot;); &#125; @Override public void walk() &#123; System.out.println(&quot;男人霸气的走路&quot;); &#125;&#125;输出结果：父类空参构造器子类空参构造器男人多吃肉，长肌肉男人霸气的走路 对象类型转换（casting） 基本数据类型的 Casting： 自动类型转换：小的数据类型可以自动转换成大的数据类型。如 long g &#x3D; 20; double d &#x3D; 12.0f;。 强制类型转换：可以把大的数据类型强制转换（casting）成小的数据类型。如 float f &#x3D; (float)12.0; int a &#x3D; (int)1200L;。 对 Java 对象的强制类型转换，也称为造型： 从子类到父类的类型转换可以自动进行。 从父类到子类的类型转换必须通过造型（强制类型转换）实现。 无继承关系的引用类型间的转换是非法的。 在造型前可以使用 instanceof 判断。 示例： 12345678910111213141516171819202122232425262728293031public class ConversionTest &#123; public static void main(String[] args) &#123; double d = 13.4; long l = (long) d; System.out.println(l); int in = 5; // boolean b = (boolean)in; Object obj = &quot;Hello&quot;; String objStr = (String) obj; System.out.println(objStr); Object objPri = new Integer(5); // 下面代码运行时引发 ClassCastException 异常 String str = (String) objPri; &#125;&#125;public class Test &#123; public void method(Person e) &#123; // 假设 Person 类中没有 getSchool() 方法 // System.out.pritnln(e.getSchool());// 非法，编译时错误 if (e instanceof Student) &#123; Student me = (Student) e;// 将 e 强制转换为 Student 类型 System.out.pritnln(me.getSchool()); &#125; &#125; public static void main(String[] args) &#123; Test t = new Test(); Student m = new Student(); t.method(m); &#125;&#125; 包装类（Wrapper）的使用包装类：也叫封装类，是针对八种基本数据类型定义的相应的引用数据类型，以使得基本数据类型的变量具有类的特征。 JDK 1.5 之后，支持自动装箱，自动拆箱，但类型必须匹配。 基本类型、包装类与 String 类之间的转换： 基本数据类型转换成包装类： 装箱：基本数据类型包装成包装类的实例，通过包装类的构造器实现。例如：int i &#x3D; 500; Integer t &#x3D; new Integer(i);。 自动装箱，例如：int i &#x3D;500; Integer t &#x3D; i;。 包装类转换成基本数据类型： 拆箱：获得包装类对象中包装的基本类型变量，通过调用包装类的.xxxValue()方法。例如：boolean b &#x3D; bObj.booleanValue();。 自动拆箱，例如：Integer t &#x3D; 500; int i &#x3D; t;。 基本数据类型&#x2F;包装类转换成字符串： 调用字符串重载的valueOf()方法，例如：String fstr &#x3D; String.valueOf(2.34f);。 更直接的方式，连接运算，例如：String intStr &#x3D; 5 + “”;。 字符串转换成基本数据类型&#x2F;包装类： 通过包装类的构造器实现，例如：int i &#x3D; new Integer(“12”);。 通过包装类的parseXxx(String s)静态方法，例如：Float f &#x3D; Float.parseFloat(“12.1”);。 面试题： 12345678910111213141516171819202122232425public static void main(String[] args) &#123; // 三目运算符比较基本数据类型，在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求表达式 2 和表达式 3 类型一致， // 所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型），再自动装箱为 Object，输出时使用多态调用重写的 toString()， // 即 Double 包装类的 toString() 方法 Object o1 = true ? new Integer(1) : new Double(2.0); System.out.println(o1);// 1.0 Object o2; if (true) o2 = new Integer(1); else o2 = new Double(2.0); System.out.println(o2);// 1&#125;public static void main(String[] args) &#123; Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j);// new了两个对象，false Integer m = 1; Integer n = 1; System.out.println(m == n);// 自动装箱，且在 -128 ~ 127 范围内，true Integer x = 128;// 相当于 new Integer(128); Integer y = 128;// 相当于 new Integer(128); System.out.println(x == y);// false&#125; Integer 类内部定义了 IntegerCache 结构，IntegerCache 中定义了一个 Integer[] 数组，保存了从-128 ~ 127范围的整数。如果使用了自动装箱的方式，给 Integer 赋值在 -128 ~ 127 范围内时，可以直接使用数组中的元素，不用 new。目的：提高效率。如果赋值超过了此范围，会 new 一个新对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 利用 Vector 代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级 * 提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度，而向量类 java.util.Vector 可以根据需要动态伸缩 *  创建Vector对象：Vector v = new Vector(); *  给向量添加元素：v.addElement(Object obj);// obj必须是对象 *  取出向量中的元素：Object obj = v.elementAt(0); *  注意第一个元素的下标是 0，返回值是 Object 类型的 *  计算向量的长度：v.size(); *  若与最高分相差10分内：A等；20分内: B等；30分内: C等；其它: D等 */public class ScoreTest &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); Vector&lt;Object&gt; objects = new Vector&lt;&gt;(); int maxScore = -1; while (true) &#123; int nextScore = scanner.nextInt(); if (nextScore &lt; 0) &#123; break; &#125; if (nextScore &gt; 100) &#123; continue; &#125; objects.add(nextScore);// 自动装箱 if (maxScore &lt; nextScore) &#123; maxScore = nextScore; &#125; &#125; char level; for (int i = 0; i &lt; objects.size(); i++) &#123; Object object = objects.elementAt(i); int score = (Integer) object;// 自动拆箱 if (maxScore - score &lt; 10) &#123; level = &#x27;A&#x27;; &#125; else if (maxScore - score &lt; 20) &#123; level = &#x27;B&#x27;; &#125; else if (maxScore - score &lt; 30) &#123; level = &#x27;C&#x27;; &#125; else &#123; level = &#x27;D&#x27;; &#125; System.out.println(&quot;Student-&quot; + i + &quot; score is &quot; + score + &quot;, level is &quot; + level); &#125; &#125;&#125; Object 类的使用1Object 类是所有 Java 类的根父类。 如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object 类。 验证方法： 123456789public class ObjectTest &#123; public static void main(String[] args) &#123; Base base = new Base(); System.out.println(&quot;父类：&quot; + base.getClass().getSuperclass());// 父类：class java.lang.Object &#125;&#125; class Base &#123;&#125; Object 类中的主要结构： &#x3D;&#x3D; 与 equals()**==**： 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等，不一定类型要相同。 12345678910111213141516public static void main(String[] args) &#123; int i = 10; int j = 10; System.out.println(i == j);// true double k = 10.0; System.out.println(i == k);// true char c = 10; System.out.println(i == c);// true char c1 = &#x27;A&#x27;; char c2 = 65; System.out.println(c1 == c2);// true&#125; 如果比较的是引用数据类型变量：比较两个变量的地址值是否相同，即两个引用是否指向同一个对象实体。 12345678910// String 类比较特殊，要注意public static void main(String[] args) &#123; String s1 = &quot;javacdfa&quot;;// 这样写的 javacdfa，位于常量池中 String s2 = &quot;javacdfa&quot;; System.out.println(s1 == s2);// true String s3 = new String(&quot;iam&quot;);// 这样 new 的，在堆内存中 String s4 = new String(&quot;iam&quot;); System.out.println(s3 == s4);// false&#125; 用 &#x3D;&#x3D; 进行比较时，符号两边的数据类型必须兼容（可自动转换的基本数据类型除外），否则编译出错。 **equals()**： 是一个方法，而非运算符，只能适用于引用数据类型。 使用格式：obj1.equals(obj2)。 所有类都继承了 Object，也就获得了 equals() 方法，也可以对其重写 。 Object 类中 equals() 方法的定义： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 说明：其作用与 &#x3D;&#x3D; 相同，比较是否指向同一个对象 。 像 File、String、Date 及包装类等，都重写了 Object 类中的 equals() 方法，重写以后，比较的不是两个引用对象的地址是否相同，而是比较两个引用对象的 “实体内容” 是否相同。比如 String 类的 equals() 方法： 1234567891011121314151617181920212223public boolean equals(Object anObject) &#123; // 先判断地址 if (this == anObject) &#123; return true; &#125; // 再判断内容 if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 通常情况下，自定义的类使用 equals() 方法时，也是比较两个引用对象的 “实体内容” 是否相同，那么，就应该重写 equals() 方法。 重写 equals() 方法的原则： 对称性：如果 x.equals(y) 返回是 true，那么 y.equals(x) 也应该返回是 true。 自反性：x.equals(x) 必须返回是 true。 传递性：如果 x.equals(y) 返回 true，而且 y.equals(z) 返回 true，那么 z.equals(x) 也应该返回 true。 一致性：如果 x.equals(y) 返回是 true，只要 x 和 y 内容一直不变，不管重复 x.equals(y) 多少次，返回都是 true。 任何情况下，x.equals(null)永远返回 false；x.equals(和x不同类型的对象)永远返回 false。 &#x3D;&#x3D; 和 equals() 的区别： &#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型是比较值，对于引用类型是比较内存地址。 equals() 方法属于 java.lang.Object 类里面的方法，如果该方法没有被重写过，默认也是 &#x3D;&#x3D;。 具体到特定自定义的类，要看该类里有没有重写 Object 的 equals() 方法以及重写的逻辑。 通常情况下，重写 equals() 方法，是比较类中的相应属性是否都相等。 toString()当输出一个对象的引用时，实际上就是调用当前对象的toString()方法。 1234567891011public class ObjectTest &#123; public static void main(String[] args) &#123; Order order = new Order(); System.out.println(order);// cn.zeloud.database.Order@78308db1 System.out.println(order.toString());// cn.zeloud.database.Order@78308db1 &#125;&#125; class Order &#123; &#125; Object 类中 toString() 方法的定义： 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 像 File、String、Date 及包装类等，都重写了 Object 类中的 toString() 方法，使得在调用对象的 toString() 方法时，返回相应的 “实体内容”。 自定义类也可以重写 toString() 方法，当调用此方法时，返回相应的 “实体内容”。比如 String 类的 toString() 方法： 123public String toString() &#123; return this;&#125; 基本类型数据转换为 String 类型时，调用了对应包装类的 toString() 方法。 面试题： 12345678public static void main(String[] args) &#123; char[] arr = new char[] &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; &#125;; System.out.println(arr);// abc int[] arr1 = new int[] &#123; 1, 2, 3 &#125;; System.out.println(arr1);// [I@78308db1 double[] arr2 = new double[] &#123; 1.1, 2.2, 3.3 &#125;; System.out.println(arr2);// [D@27c170f0&#125; main()由于 Java 虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 public，又因为 Java 虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数。 又因为 main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。 main() 方法的使用说明： main() 方法是程序的入口。 main() 方法也是一个普通的静态方法，在执行某个类的 main() 方法之前，需要先加载这个类，这个过程是早于 main() 方法中首行的执行语句的。 main() 方法可以作为程序与控制台交互的方式之一，其他的还可以使用 Scanner 类。 命令行参数用法举例：","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"《JAVA基础》：面向对象","slug":"《JAVA基础》：面向对象-1","date":"2024-12-23T09:30:46.000Z","updated":"2024-12-23T10:40:54.794Z","comments":true,"path":"2024/12/23/《JAVA基础》：面向对象-1/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/23/%E3%80%8AJAVA%E5%9F%BA%E7%A1%80%E3%80%8B%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/","excerpt":"概述面向过程和面向对象的区别： 二者都是一种思想，面向对象是相对于面向过程而言的 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做；将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。 例如，人把大象装进冰箱：","text":"概述面向过程和面向对象的区别： 二者都是一种思想，面向对象是相对于面向过程而言的 面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做；将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。 例如，人把大象装进冰箱： 面向对象的思想概述： 程序员从面向过程的执行者转变为面向对象的指挥者 面向对象分析方法分析问题的思路和步骤： 根据问题需要，选择问题所针对的现实世界中的实体。 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。 将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。 Java 面向对象的三条主线： 类及类的成员：属性，方法，构造器，代码块，内部类 关键字：instanceof、this、super、static、final、package、import、abstract、interface等。 面向对象的三大特征：封装性（Encapsulation）、继承性（Inheritance）、多态性（Polymorphism）、（抽象性）。 类和对象**类（Class）和对象（Object）**是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义。 对象是实际存在的该类事物的每个个体，因而也称为实例（instance）。 类的定义创建 Java 自定义类步骤： 定义类：考虑修饰符、类名。 编写类的属性：考虑修饰符、属性类型、属性名、初始化值。 编写类的方法：考虑修饰符、返回值类型、方法名、形参等。 按需编写类的构造器、代码块和内部类等。 类的语法格式： 1234567891011修饰符 class 类名 &#123; 属性声明; 构造器声明; 方法声明; 代码块声明; 内部类声明;&#125; 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344package duixiang;public class Person &#123; // 属性，或成员变量 String name; int age; boolean isMale; // 构造方法 public Person() &#123; System.out.println(&quot;Person类的无参构造方法执行了&quot;); &#125; public Person(String name, int age, boolean isMale)&#123; this.name = name; this.age = age; this.isMale = isMale; &#125; // 方法，或函数 public void walk()&#123; System.out.println(name + &quot;在走路&quot;); &#125; public String display()&#123; return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age + &quot;，性别：&quot; + (isMale ? &quot;男&quot; : &quot;女&quot;); &#125; // 代码块 &#123; System.out.println(&quot;Person类的代码块执行了&quot;); name = &quot;张三&quot;; age = 18; isMale = true; &#125; // 内部类 class Pet&#123; String name; float weight; &#125;&#125; 类的访问机制： 在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。例外：static 方法访问非 static 属性，编译不通过。 在不同类中的访问机制： 先创建要访问类的对象， 再用对象访问类中定义的成员 对象的定义1类名 对象名 = new 类名(); 使用对象名.对象成员的方式访问对象成员，包括属性和方法。示例： 1234567891011121314151617181920212223242526public class Animal &#123; public int legs; public void eat() &#123; System.out.println(&quot;Eating&quot;); &#125; public void move() &#123; System.out.println(&quot;Moving&quot;); &#125; public static void main(String[] args) &#123; // 创建对象 Animal animal = new Animal(); // 访问属性 animal.legs = 4; System.out.println(animal.legs); // 访问方法 animal.eat(); // 访问方法 animal.move(); &#125;&#125; 匿名对象：不定义对象的句柄，而直接调用这个对象的方法，这样的对象叫做匿名对象。例如：”new Person().shout();”。如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象，我们经常将匿名对象作为实参传递给一个方法调用。 权限修饰符权限修饰符：置于类的成员定义前，用来限定对象对该类成员的访问权限。权限从小到大排列：private、缺省（什么都不写）、protected、public。 权限修饰符可以用来修饰类及类的内部结构：属性、方法、构造器、内部类。 对于 class 的权限修饰只可以用 public 和 default（缺省）。 public 类可以在任意地方被访问。 default 类只可以被同一个包内部的类访问。 对于 class 的内部结构，四种权限修饰符都可以使用。 总结：Java 提供了 4 种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。 属性（field）1修饰符 数据类型 属性名 = 初始化值; 常用的权限修饰符有：private、缺省、protected、public。其他修饰符：static、final。 数据类型：任何基本数据类型（如 int、boolean 等）或任何引用数据类型。 属性名：属于标识符，符合命名规则和规范即可。 属性（成员变量）与局部变量的区别： 局部变量的默认初始化值：局部变量声明后，没有默认初始化值，必须显式赋值，方可使用。特别的，形参在调用时，赋值即可。 成员变量的默认初始化值：当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变量类型都是引用类型。 方法（method）方法的定义什么是方法（method 、函数）： 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。 将功能封装为方法的目的是，可以实现代码重用，简化代码。 Java 里的方法不能独立存在，所有的方法必须定义在类里。 语法格式： 1234修饰符 返回值类型 方法名([参数类型 形参, ...]) &#123; 方法体; retrun 返回值;&#125; 权限修饰符：public，缺省，private，protected 等。 返回值类型： 没有返回值：使用 void。 有返回值：在方法声明时，必须指定返回值的类型，同时，方法体中需要使用 return 关键字返回指定类型的变量或常量。 方法名 ：属于标识符，命名时遵循标识符命名规则和规范，能够见名知意。 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用 “,” 隔开。 方法体：方法功能的具体实现。 返回值：方法在执行完毕后返还给调用它的程序的数据。 方法的调用： 方法通过方法名被调用，且只有被调用才会执行。 方法被调用一次，就会执行一次。 没有具体返回值的情况，返回值类型用关键字 void 表示，此时方法体中可以不必使用 return 语句。如果使用，表示用来结束方法。 定义方法时，方法的结果应该返回给调用者，交由调用者处理。 方法中可以调用当前类的属性或方法，不可以在方法内部定义方法。 可变个数的形参JavaSE 5.0 中提供了Varargs（variable number of arguments）机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 语法格式：方法名(参数的类型名... 参数名) 可变参数的特点： 方法参数部分指定类型的参数个数是可变多个 —&gt; 0 个，1 个或多个。 可变个数形参的方法与同名的方法之间，彼此构成重载。 可变参数方法的使用与方法参数部分使用数组是一致的，二者不共存。如下所示，方法二与方法三是相同的，不共存： 12345678910// 方法二public static void show(int... m) &#123; // m 参数等同于数组，与数组的使用方法相同 System.out.println(Arrays.toString(m));&#125; // 方法三public static void show(int[] m) &#123; System.out.println(m);&#125; 方法的参数部分有可变形参，需要放在形参声明的最后。 // 合法 public static void show(String str, int... m) &#123; System.out.println(Arrays.toString(m)); &#125; // 不合法 public static void show(int... m, String str) &#123; System.out.println(Arrays.toString(m)); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- 在一个方法的形参位置，最多只能声明一个可变个数形参。#### 方法参数的值传递机制方法，必须由其所在类或对象调用才有意义。若方法含有参数：- `形参`：方法声明时的参数。- `实参`：方法调用时实际传给形参的数据。Java 的实参值如何传入方法呢？Java 里方法的参数传递方式只有一种：**`值传递`**， 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。- **形参是基本数据类型：将实参基本数据类型变量的`&quot;数据值&quot;`传递给形参。**- **形参是引用数据类型：将实参引用数据类型变量的`&quot;地址值&quot;`传递给形参。**形参是基本数据类型与引用数据类型之间的区别：```javapublic class ValueTransferTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;***************基本数据类型***************&quot;); int m = 10; int n = m; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); n = 20; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); System.out.println(&quot;***************引用数据类型***************&quot;); Order o1 = new Order(); o1.orderId = 1001; Order o2 = o1;// 赋值后，o1 和 o2 的地址值相同，都指向了堆空间中的同一个实体 System.out.println(&quot;o1.orderId = &quot; + o1.orderId + &quot;, o2.orderId = &quot; + o2.orderId); o2.orderId = 1002; System.out.println(&quot;o1.orderId = &quot; + o1.orderId + &quot;, o2.orderId = &quot; + o2.orderId); &#125;&#125; class Order &#123; int orderId;&#125;输出结果：***************基本数据类型***************m = 10, n = 10m = 10, n = 20***************引用数据类型***************o1.orderId = 1001, o2.orderId = 1001o1.orderId = 1002, o2.orderId = 1002 对于基本数据类型，两个不同方法内的局部变量，互不影响。不因变量名相同而改变，因为是将实参基本数据类型变量的 “数据值” 传递给形参。 12345678910111213141516171819202122232425262728293031323334public class ValueTransferTest &#123; public void swap(int m, int n) &#123; System.out.println(&quot;swap方法中, 交换之前: m = &quot; + m + &quot;, n = &quot; + n); int temp = m; m = n; n = temp; System.out.println(&quot;swap方法中, 交换之后: m = &quot; + m + &quot;, n = &quot; + n); &#125; public static void main(String[] args) &#123; int m = 10; int n = 20; System.out.println(&quot;main方法中, 交换之前: m = &quot; + m + &quot;, n = &quot; + n); // 能够交换 m 和 n 的值 int temp = m; m = n; n = temp; System.out.println(&quot;main方法中, 交换之后: m = &quot; + m + &quot;, n = &quot; + n); // 不能够交换 m 和 n 的值 ValueTransferTest valueTransferTest = new ValueTransferTest(); System.out.println(&quot;main方法中, 调用swap方法之前: m = &quot; + m + &quot;, n = &quot; + n); valueTransferTest.swap(m, n);// // swap 方法调用完成后，该方法内的局部变量 temp，形参 m 和 n 从栈内存中弹出回收 System.out.println(&quot;main方法中, 调用swap方法之后: m = &quot; + m + &quot;, n = &quot; + n); &#125;&#125;输出结果：main方法中, 交换之前: m = 10, n = 20main方法中, 交换之后: m = 20, n = 10main方法中, 调用swap方法之前: m = 20, n = 10swap方法中, 交换之前: m = 20, n = 10swap方法中, 交换之后: m = 10, n = 20main方法中, 调用swap方法之后: m = 20, n = 10 对于引用数据类型，两个不同方法的局部变量，会互相影响。因为是将实参引用数据类型变量的 “地址值” 传递给形参，二者指向的是堆内存中的同一个对象。 12345678910111213141516171819202122232425262728293031323334353637383940public class ValueTransferTest &#123; public void swap(Data data) &#123; System.out.println(&quot;swap方法中, 交换之前: data.m = &quot; + data.m + &quot;, data.n = &quot; + data.n); int temp = data.m; data.m = data.n; data.n = temp; System.out.println(&quot;swap方法中, 交换之后: data.m = &quot; + data.m + &quot;, data.n = &quot; + data.n); &#125; public static void main(String[] args) &#123; Data data = new Data(); data.m = 10; data.n = 20; System.out.println(&quot;main方法中, 交换之前: data.m = &quot; + data.m + &quot;, data.n = &quot; + data.n); // 能够交换 m 和 n 的值 int temp = data.m; data.m = data.n; data.n = temp; System.out.println(&quot;main方法中, 交换之后: data.m = &quot; + data.m + &quot;, data.n = &quot; + data.n); // 能够交换 m 和 n 的值 ValueTransferTest valueTransferTest = new ValueTransferTest(); System.out.println(&quot;main方法中, 调用swap方法之前: data.m = &quot; + data.m + &quot;, data. = &quot; + data.n); valueTransferTest.swap(data);// swap 方法调用完成后，该方法内的局部变量 temp 和形参 data 从栈内存中弹出回收 System.out.println(&quot;main方法中, 调用swap方法之后: data.m = &quot; + data.m + &quot;, data.n = &quot; + data.n); &#125;&#125; class Data &#123; int m; int n;java&#125;输出结果：main方法中, 交换之前: data.m = 10, data.n = 20main方法中, 交换之后: data.m = 20, data.n = 10main方法中, 调用swap方法之前: data.m = 20, data. = 10swap方法中, 交换之前: data.m = 20, data.n = 10swap方法中, 交换之后: data.m = 10, data.n = 20main方法中, 调用swap方法之后: data.m = 10, data.n = 20 示例： 1234567891011121314151617181920212223242526public class ValueTransferTest &#123; public void first() &#123; int i = 5; Value v = new Value(); v.i = 25; second(v, i); System.out.println(v.i);// 20 &#125; public void second(Value v, int i) &#123; i = 0; v.i = 20; Value val = new Value(); v = val; System.out.println(v.i + &quot; &quot; + i);// 15 0 &#125; public static void main(String[] args) &#123; ValueTransferTest test = new ValueTransferTest(); test.first(); &#125;&#125; class Value &#123; int i = 15;&#125; 示例二： 12345678910public class Test &#123; public static void main(String[] args) &#123; int a = 10; int b = 10; method(a, b); // 需要在代码编写处添加方法method，仅打印出a=100,b=200,请写出方法method的代码 System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b); &#125; // 代码编写处&#125; 方法一： 123456789101112131415public class Test &#123; public static void method(int a, int b) &#123; System.out.println(&quot;a = &quot; + a * 10); System.out.println(&quot;b = &quot; + b * 20); System.exit(0); &#125; public static void main(String[] args) &#123; int a = 10; int b = 10; method(a, b); System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b); &#125;&#125; 方法二 123456789101112131415161718192021222324public class Test &#123; public static void method(int a, int b) &#123; PrintStream printStream = new PrintStream(System.out) &#123; @Override public void println(String x) &#123; if (&quot;a = 10&quot;.equals(x)) &#123; x = &quot;a = 100&quot;; &#125; else if (&quot;b = 10&quot;.equals(x)) &#123; x = &quot;b = 200&quot;; &#125; super.println(x); &#125; &#125;; System.setOut(printStream); &#125; public static void main(String[] args) &#123; int a = 10; int b = 10; method(a, b); System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b); &#125;&#125; 示例三：定义一个 int 型的数组int[] arr = new int[]&#123;12,3,3,34,56,77,432&#125;;，让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的新值，然后遍历新的数组。 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;12, 3, 3, 34, 56, 77, 432&#125;; System.out.println(&quot;计算前: &quot; + Arrays.toString(arr)); // 正确写法一 int temp = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] / temp; &#125; // 正确写法二 for (int i = arr.length - 1; i &gt;= 0; i--) &#123; arr[i] = arr[i] / arr[0]; &#125; // 错误写法，因为第一次循环之后，首位置上的数已经改变，不再是最开始的值 /*for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] / arr[0]; &#125;*/ System.out.println(&quot;计算后: &quot; + Arrays.toString(arr)); &#125;&#125; 示例四： 123456789101112public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, 2, 3&#125;; System.out.println(arr);// 地址值 char[] arr1 = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; System.out.println(arr1);// 传入 char 数组时，println 方法体内是遍历这个数组 &#125;&#125;输出结果：[I@78308db1abc 方法的重载（overload）概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 方法重载的要求： 与方法的权限修饰符、返回值类型、形参变量名、方法体都无关，只看参数列表，且参数列表（参数个数、参数类型或参数顺序）必须不同。调用时，根据方法参数列表的不同来区别。 下面示例中，如果方法一不存在，main 方法依然正常执行，此时涉及到的是自动类型转换： 12345678910111213// 方法一public static int getSum(int m, int n) &#123;return m + n;&#125; // 方法二public static double getSum(double m, double n) &#123;return m + n;&#125; public static void main(String[] args) &#123;System.out.println(getSum(1, 2));&#125; 方法的重写（override&#x2F;overwrite）概念：在子类中可以根据需要，对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类重写的方法将覆盖父类的方法。 方法重写的要求： 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限（权限修饰符）。 子类不能重写父类中声明为 private 权限的方法。 子类中可以声明与父类 private 方法相同名称和参数列表的方法，但不属于重写。 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。 父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void。 父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类。 父类被重写的方法的返回值类型是基本数据类型（比如：double），则子类重写的方法的返回值类型必须是相同的基本数据类型（即，只能是 double）。 子类重写的方法抛出的异常类型不能大于父类被重写的方法抛出的异常类型。 子类与父类中同名同参数的方法必须同时声明为非 static 的（此时属于重写），或者同时声明为 static 的（此时不属于重写）。因为 static 方法是属于类的，子类无法覆盖父类的方法。 此时，子类中的该方法也须遵循重写关于访问权限、返回值和抛出异常类型等方面的规则。 方法重载与重写的区别： 二者的定义细节：略。 从编译和运行的角度看：重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java 的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为&quot;早绑定&quot;或&quot;静态绑定&quot;；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为&quot;晚绑定&quot;或&quot;动态绑定&quot;。引用一句 Bruce Eckel 的话：”不要犯傻，如果它不是晚绑定，它就不是多态。” 重载不表现为多态性，重写表现为多态性。 递归方法（recursion）定义：一个方法体内调用它自身。方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 示例： 1234567891011121314151617181920212223242526272829303132public class PassObject &#123; // 1 ~ n 之间所有自然数的和 public static int getSum(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n + getSum(n - 1); &#125; &#125; // 1 ~ n 之间所有自然数的乘积 public static long getProduct(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * getProduct(n - 1); &#125; &#125; public static void main(String[] args) &#123; // 方式一：循环 int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; System.out.println(&quot;1-100之间自然数的和: &quot; + sum); // 方式二：递归 System.out.println(&quot;1-100之间自然数的和: &quot; + getSum(100)); System.out.println(&quot;1-100之间自然数的积: &quot; + getProduct(5)); &#125;&#125; 示例二： 123456789101112131415161718192021/** * 已知有一个数列: f(0) = 1，f(1) = 4，f(n+2) = 2 * f(n+1) + f(n)，其中 n 是大于 0 的整数，求 f(10) 的值 */public class PassObject &#123; public static int f(int n) &#123; if (n == 0) &#123; return 1; &#125; else if (n == 1) &#123; return 4; &#125; else &#123; return 2 * f(n - 1) + f(n - 2); &#125; &#125; public static void main(String[] args) &#123; int f = f(10); System.out.println(f); &#125;&#125;输出结果：10497 示例三： 123456789101112131415161718192021/** * 已知一个数列: f(20) = 1，f(21) = 4，f(n+2) = 2 * f(n+1) + f(n)，其中 n 是大于 0 的整数，求 f(10) 的值 */public class PassObject &#123; public static int f(int n) &#123; if (n == 20) &#123; return 1; &#125; else if (n == 21) &#123; return 4; &#125; else &#123; return f(n + 2) - 2 * f(n + 1); &#125; &#125; public static void main(String[] args) &#123; int f = f(10); System.out.println(f); &#125;&#125;输出结果：-3771 示例四： 12345678910111213141516171819202122232425262728293031323334/** * 斐波那契数列：1 1 2 3 5 8 13 21 34 55 ... * 规律：一个数等于前两个数之和 * 要求：计算斐波那契数列（Fibonacci）的第 n 个值，并将整个数列打印出来 */public class PassObject &#123; public static int f(int n) &#123; if (n &lt;= 0 || n &gt;= 30) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; else if (n == 2) &#123; return 1; &#125; else &#123; return f(n - 1) + f(n - 2); &#125; &#125; public static void main(String[] args) &#123; int[] arr = new int[5]; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = f(i + 1); sum += arr[i]; &#125; System.out.println(Arrays.toString(arr)); System.out.println(&quot;和: &quot; + sum); &#125;&#125;输出结果：[1, 1, 2, 3, 5]和: 12 示例五： 1234567891011121314151617181920212223242526272829303132public class PassObject &#123; private static int count = 0; public static int recursion(int k) &#123; count++; System.out.println(&quot;count1: &quot; + count + &quot;, k: &quot; + k); if (k &lt;= 0) &#123; return 0; &#125; return recursion(k - 1) + recursion(k - 2); &#125; public static void main(String[] args) &#123; recursion(4); &#125;&#125;输出结果：count1: 1, k: 4count1: 2, k: 3count1: 3, k: 2count1: 4, k: 1count1: 5, k: 0count1: 6, k: -1count1: 7, k: 0count1: 8, k: 1count1: 9, k: 0count1: 10, k: -1count1: 11, k: 2count1: 12, k: 1count1: 13, k: 0count1: 14, k: -1count1: 15, k: 0 构造器（constructor）构造器，也叫构造方法。 作用： 创建对象。如：Order o = new Order();。 给对象进行初始化。如：Person p = new Person(“Peter”, 15);。 语法格式： 123修饰符 类名(参数列表) &#123; 初始化语句;&#125; 根据参数不同，构造器可以分为如下两类： 隐式无参构造器（系统默认提供）。 显式定义一个或多个构造器（无参、有参）。 构造器的特征： 构造器具有与类相同的名称，不声明返回值类型，与声明为 void 不同。 Java 语言中，每个类都至少有一个构造器。 如果没有显示的定义类的构造器，则系统默认提供一个无参构造器。一旦显式定义了构造器， 则系统不再提供默认构造器。 一般情况下，为了防止一些框架出异常，无论要不要自定义其他构造器，都应该把类的无参构造器显示的定义出来。 构造器的修饰符默认与所属类的修饰符一致，即：public 或 default（缺省）。 构造器不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值。 一个类中定义的多个构造器，彼此构成重载。 父类的构造器不可被子类继承。 代码块（或初始化块）代码块的作用：对 Java 类或对象进行初始化。 代码块的分类：一个类中代码块若有修饰符，则只能被 static 修饰，称为静态代码块（static block），没有使用 static 修饰的，为非静态代码块。 静态代码块： 内部可以有输出语句。 随着类的加载而执行，而且只执行一次。（不同于静态方法，静态方法必须在被类显示的调用后，才会执行方法内的语句。） 作用：初始化类的信息。 如果一个类定义了多个静态代码块，则按照声明的先后顺序来执行。一般情况下，不建议定义多个。 静态代码块的执行要优先于非静态代码块的执行，与声明的先后顺序无关。 静态代码块中，只能调用静态的属性、静态的方法，不能调用非静态的属性、非静态的方法。 非静态代码块： 内部可以有输出语句。 随着对象的创建而执行。（不同于非静态方法，非静态方法必须在被类的对象显示的调用后，才会执行方法内的语句。） 每创建一个对象，就执行一次非静态代码块，且先于构造器执行。 作用：可以在创建对象时，对对象的属性等进行初始化。 如果一身上个类定义了多个非静态代码块，则按照声明的先后顺序来执行。一般情况下，不建议定义多个。 非静态代码块中，可以调用静态的属性、静态的方法，也可以调用非静态的属性、非静态的方法。 代码块及构造器的执行顺序： 由父及子，静态先行。 注意：调用 main() 方法时，需要先加载类，这个过程是早于 main() 方法中的首行执行语句的。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Root &#123; static &#123; System.out.println(&quot;Root的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Root的普通初始化块&quot;); &#125; public Root() &#123; System.out.println(&quot;Root的无参数的构造器&quot;); &#125;&#125; class Mid extends Root &#123; static &#123; System.out.println(&quot;Mid的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Mid的普通初始化块&quot;); &#125; public Mid() &#123; System.out.println(&quot;Mid的无参数的构造器&quot;); &#125; public Mid(String msg) &#123; // 通过 this 调用同一类中重载的构造器 this(); System.out.println(&quot;Mid的带参数构造器，其参数值：&quot; + msg); &#125;&#125; class Leaf extends Mid &#123; static &#123; System.out.println(&quot;Leaf的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Leaf的普通初始化块&quot;); &#125; public Leaf() &#123; // 通过 super 调用父类中有一个字符串参数的构造器 super(&quot;ABC&quot;); System.out.println(&quot;Leaf的构造器&quot;); &#125;&#125; public class LeafTest &#123; public static void main(String[] args) &#123; new Leaf(); System.out.println(); new Leaf(); &#125;&#125;输出结果：Root的静态初始化块Mid的静态初始化块Leaf的静态初始化块Root的普通初始化块Root的无参数的构造器Mid的普通初始化块Mid的无参数的构造器Mid的带参数构造器，其参数值：ABCLeaf的普通初始化块Leaf的构造器 Root的普通初始化块Root的无参数的构造器Mid的普通初始化块Mid的无参数的构造器Mid的带参数构造器，其参数值：ABCLeaf的普通初始化块Leaf的构造器 示例二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Father &#123; static &#123; System.out.println(&quot;11111111111&quot;); &#125; &#123; System.out.println(&quot;22222222222&quot;); &#125; public Father() &#123; System.out.println(&quot;33333333333&quot;); &#125; // main 方法是一个静态方法，执行某个类的 main 方法之前，要先加载这个类，此处是 Father 类 public static void main(String[] args) &#123; System.out.println(&quot;77777777777&quot;); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Father(); &#125;&#125; class Son extends Father &#123; static &#123; System.out.println(&quot;44444444444&quot;); &#125; &#123; System.out.println(&quot;55555555555&quot;); &#125; public Son() &#123; System.out.println(&quot;66666666666&quot;); &#125; // main 方法是一个静态方法，执行某个类的 main 方法之前，要先加载这个类，此处是先加载 Son 类 public static void main(String[] args) &#123; // 由父及子 静态先行 System.out.println(&quot;77777777777&quot;); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Father(); &#125;&#125; public class Test &#123; // main 方法是一个静态方法，执行某个类的 main 方法之前，要先加载这个类，此处是先加载 Test 类 public static void main(String[] args) &#123; System.out.println(&quot;77777777777&quot;); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Father(); &#125;&#125; 调用 Father 类的 main() 方法，要先加载 Father 类。输出结果： 12345678910111213141516F: 11111111111F/m: 77777777777F/m: ************************S: 44444444444F: 22222222222F: 33333333333S: 55555555555S: 66666666666F/m: ************************F: 22222222222F: 33333333333S: 55555555555S: 66666666666F/m: ************************F: 22222222222F: 33333333333 调用 Son 类的 main() 方法，要先加载 Son 类。输出结果： 12345678910111213141516F: 11111111111S: 44444444444S/m: 77777777777S/m: ************************F: 22222222222F: 33333333333S: 55555555555S: 66666666666S/m: ************************F: 22222222222F: 33333333333S: 55555555555S: 66666666666S/m: ************************F: 22222222222F: 33333333333 调用 Test 类的 main() 方法，要先加载 Test 类。输出结果： 12345678910111213141516T/m: 77777777777T/m: ************************F: 11111111111S: 44444444444F: 22222222222F: 33333333333S: 55555555555S: 66666666666T/m: ************************F: 22222222222F: 33333333333S: 55555555555S: 66666666666T/m: ************************F: 22222222222F: 33333333333 内部类当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为当前外部事物提供服务，那么整个内部的完整结构最好使用内部类。 在 Java 中，允许一个类 A 声明在另一个类 B 的内部，则类 A 称为内部类，类 B 称为外部类。 Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。Inner class 的名字不能与包含它的外部类类名相同。 内部类的分类：成员内部类（静态的、非静态的），局部内部类（代码块内、构造器内、方法内）。 成员内部类成员内部类的特点： 一方面，作为外部类的成员： 调用外部类的结构，注意生命周期，如静态成员内部类不能调用外部类非静态的方法。 可以被 static 修饰，但此时就不能再使用外层类的非 static 的成员变量。注意，外部类不能被 static 修饰。 可以被 private、protected、缺省和 public 四种权限修饰符修饰。注意，外部类不能被 private 和 protected 修饰。 另一方面，作为一个类： 类内可以定义属性、方法、构造器、代码块、内部类等。 可以被 final 修饰，表示此类不能被继承，如果不使用 final，就可以被继承。 可以被 abstract 修饰，表示此类不能被实例化，可以被其它的内部类继承。 编译以后生成 OuterClass$InnerClass.class 字节码文件（也适用于局部内部类）。 非 static 的成员内部类中的成员不能声明为 static 的，只有在外部类或 static 的成员内部类中才可声明 static 成员。 外部类访问成员内部类的成员，需要 “内部类.成员” 或 “内部类对象.成员” 的方式。 成员内部类可以直接使用外部类的所有成员，包括私有的数据。 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的。 局部内部类局部内部类的特点： 局部内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的 .class 文件，但是前面冠以外部类的类名和 $ 符号，以及数字编号。 只能在声明它的方法或代码块中使用，而且是先声明后使用，除此之外的任何地方都不能使用该类。 局部内部类的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型。 局部内部类可以使用外部类的成员，包括私有的。 局部内部类可以使用外部方法的局部变量，但是必须是 final 的，final 可以省略（JDK 8 及之后），但这个局部变量赋值后不能有再次修改操作，否则编译不通过。这是因为局部内部类和局部变量的声明周期不同所致。 局部内部类和局部变量地位类似，不能使用 public，缺省，protected 和 private 修饰。 局部内部类不能使用 static 修饰，因此也不能包含静态成员。 匿名内部类匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类。 语法格式： 123new 父类构造器(实参列表)|实现接口() &#123; 匿名内部类的类体部分&#125; 匿名内部类的特点： 匿名内部类必须继承父类或实现接口。 匿名内部类只能有一个对象。 匿名内部类对象只能使用多态形式引用 内部类的应用关注如下的 3 个问题： 如何实例化成员内部类的对象？ 静态成员内部类：外部类.静态内部类 变量名 = new 外部类.静态内部类();。 非静态成员内部类：外部类.非静态内部类 变量名 = new 外部类().new 非静态内部类();。 如何在成员内部类中区分调用外部类的结构？ 静态成员内部类，参考： 12345public void show(int age) &#123; System.out.println(&quot;形参：&quot; + age); System.out.println(&quot;静态成员内部类的静态属性：&quot; + Brain.age); System.out.println(&quot;外部类的静态属性：&quot; + Person.age);&#125; 非静态成员内部类，参考： 12345public void show(String name) &#123; System.out.println(&quot;形参：&quot; + name); System.out.println(&quot;非静态成员内部类的非静态属性：&quot; + this.name);// 非静态成员内部类，不能定义 static 的变量 System.out.println(&quot;外部类的非静态属性：&quot; + Person.this.name);&#125; 开发中局部内部类的使用？ 12345678910111213141516171819202122232425262728293031public class InnerClassTest1 &#123; // 这种局部内部类，开发中很少见 public void method() &#123; class AA &#123; &#125; &#125; // 返回一个实现类 Comparable 接口的类的对象 public Comparable getComparable() &#123; // 创建一个实现了 Comparable 接口的类：局部内部类 // 方式一：创建 Comparable 接口的非匿名实现类的匿名对象 /*class MyComparable implements Comparable &#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125; return new MyComparable();*/ // 方式二：创建 Comparable 接口的匿名实现类的匿名对象 return new Comparable() &#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125;; &#125;&#125; 成员内部类和局部内部类应用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class InnerClassTest &#123; public static void main(String[] args) &#123; // 1. 创建 Brain 实例---静态的成员内部类 Person.Brain brain = new Person.Brain(); brain.think(); brain.show(8); // 2. 创建 Hand 实例---非静态的成员内部类 Person.Hand hand = new Person().new Hand(); hand.grasp(); hand.show(&quot;外来手&quot;); &#125;&#125; class Person &#123; String name = &quot;小明&quot;; static int age = 8; // 静态成员内部类 static class Brain &#123; static int age = 8; public Brain() &#123; &#125; public void think() &#123; System.out.println(&quot;大脑想东西&quot;); &#125; public void show(int age) &#123; System.out.println(&quot;形参：&quot; + age); System.out.println(&quot;静态成员内部类的静态属性：&quot; + Brain.age); System.out.println(&quot;外部类的静态属性：&quot; + Person.age); &#125; &#125; // 非静态成员内部类 class Hand &#123; String name = &quot;内部手&quot;; public Hand() &#123; &#125; public void grasp() &#123; System.out.println(&quot;手抓东西&quot;); // 调用 Person 外部类的方法 Person.this.eat();// 等价于 eat()，注意方法的生命周期 &#125; public void show(String name) &#123; System.out.println(&quot;形参：&quot; + name); System.out.println(&quot;非静态成员内部类的非静态属性：&quot; + this.name); System.out.println(&quot;外部类的非静态属性：&quot; + Person.this.name); &#125; &#125; static &#123; // 静态代码块内局部内部类 class AA &#123; &#125; &#125; &#123; // 非静态代码块内局部内部类 class BB &#123; &#125; &#125; public Person() &#123; // 构造器内局部内部类 class CC &#123; &#125; &#125; public static void method1() &#123; // 静态方法内局部内部类 class DD &#123; &#125; &#125; public void method() &#123; // 非静态方法内局部内部类 class EE &#123; &#125; &#125; public void eat() &#123; &#125;&#125; 匿名内部类应用示例： 1234567891011121314151617181920212223242526272829interface Product &#123; public double getPrice(); public String getName();&#125; public class AnonymousTest &#123; public void test(Product p) &#123; System.out.println(&quot;购买了一个&quot; + p.getName() + &quot;，花掉了&quot; + p.getPrice()); &#125; public static void main(String[] args) &#123; AnonymousTest ta = new AnonymousTest(); // 调用 test 方法时，需要传入一个 Product 参数 // 此处传入其匿名实现类的实例 ta.test(new Product() &#123; @Override public double getPrice() &#123; return 567.8; &#125; @Override public String getName() &#123; return &quot;AGP显卡&quot;; &#125; &#125;); &#125;&#125; 面试题： 1234567891011121314151617181920212223public class Test &#123; public Test() &#123; Inner s1 = new Inner(); s1.a = 10; Inner s2 = new Inner(); s2.a = 20; Test.Inner s3 = new Test.Inner(); System.out.println(s3.a); &#125; class Inner &#123; public int a = 5; &#125; public static void main(String[] args) &#123; Test t = new Test(); Inner r = t.new Inner(); System.out.println(r.a); &#125;&#125;输出结果：55 关键字instanceof**a instanceof A**：检验对象 a 是否为类 A 的对象实例，如果是，返回 true，如果不是，返回 false。 使用情景：为了避免向下转型时出现 java.lang.ClassCastException，在向下转型之前，先进行 instanceof 判断，在返回 true 时，才进行向下转型。 要求 a 所属的类与类 A 必须是子类和父类的关系，否则编译错误。 如果 a 属于类 A 的子类 B，a instanceof A 的返回值也为 true。 this**this**： this 理解为：当前对象或当前正在创建的对象。 this 可以用来修饰或调用：属性、方法、构造器。 this 修饰属性和方法： 在类的方法中，可以使用 “this.属性” 或 “this.方法” 的方式，调用当前属性或方法。 通常情况下，可以省略 “this.”。 特殊情况下，如果方法的形参和类的属性同名，则必须显示的使用 “this.变量” 的方式，表明此变量是属性，而非形参。 在类的构造器中，可以使用 “this.属性” 或 “this.方法” 的方式，调用当前正在创建的对象的属性或方法。 通常情况下，可以省略 “this.”。 特殊情况下，如果构造器的形参和类的属性同名，则必须显示的使用 “this.变量” 的方式，表明此变量是属性，而非形参。 使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找。 this 调用构造器： 在类的构造器中，可以显示的使用 “this(形参列表)” 的方式，调用本类中的其他构造器。 存在构造器的多重调用时，创建的对象仍然是只有一个，而不是调用一个构造器就创造了一个新的对象，只有最开始被调用的构造器才创造了对象。 构造器中，不能使用 “this(形参列表)” 的方式调用自己。 如果一个类中有 n 个构造器，则最多有 n - 1 个构造器中使用了 “this(形参列表)”。 构造器在彼此调用时，不能形成一个封闭环，如：构造器 A 中调用了构造器 B，则在构造器 B 中不能再调用构造器 A，多构造器调用类推。 规定：”this(形参列表)” 必须声明在当前构造器的首行。 一个构造器内部，最多只能声明一个 “this(形参列表)”，即只能调用一个其他的构造器。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Person &#123; private String name; private int age; // 无参构造器 public Person() &#123; this.eat(); &#125; // 带 name 的构造器 public Person(String name) &#123; this();// 调用无参构造器 this.name = name; &#125; // 带 name 和 age 的构造器 public Person(String name, int age) &#123; this(name);// 调用带 name 的构造器 this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name;// 此处 this 可以省略 &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return this.age;// 此处 this 可以省略 &#125; public void eat() &#123; System.out.println(&quot;人吃饭&quot;); this.study();// this 调用方法，此处 this 可以省略 &#125; public void study() &#123; this.eat();// this 调用方法，此处 this 可以省略 System.out.println(&quot;人学习&quot;); &#125; public static void main(String[] args) &#123; &#125;&#125; 示例二： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Boy &#123; private String name; private int age; public Boy() &#123; &#125; public Boy(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void marray(Girl girl) &#123; System.out.println(&quot;我想娶&quot; + girl.getName()); &#125; public void shout() &#123; System.out.println(&quot;我想找对象&quot;); &#125;&#125;public class Girl &#123; private String name; private int age; public Girl() &#123; &#125; public Girl(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void marry(Boy boy) &#123; System.out.println(&quot;我想嫁给&quot; + boy.getName()); boy.marray(this);// 传入当前 Girl 对象 &#125; public int compare(Girl girl) &#123; return this.age - girl.age; &#125;&#125;public class Person &#123; public static void main(String[] args) &#123; Boy boy = new Boy(&quot;罗密欧&quot;, 20); boy.shout(); Girl girl = new Girl(&quot;朱丽叶&quot;, 18); girl.marry(boy); Girl girl2 = new Girl(&quot;祝英台&quot;, 19); System.out.println(&quot;年龄差：&quot; + girl.compare(girl2)); &#125;&#125; super**super**： super 理解为：父类的。 super 可以用来调用父类的：属性、方法、构造器。 在子类的方法或构造器中，可以通过使用 “super.属性” 或 “super.方法” 的形式，显示的调用父类中声明的属性或方法。 通常情况下，可以省略 “super.”。 特殊情况：当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的该属性，则必须显示的使用 “super.属性” 的方式，表明调用的是父类中声明的属性。 特殊情况：当子类重写了父类中的方法以后，要想在子类中调用父类中被重写的方法时，则必须显示的使用 “super.方法” 的方式，表明调用的是父类中被重写的方法。 在子类的构造器中，可以通过使用 “super(形参列表)” 的形式，显示的调用父类中声明的指定的构造器。 “super(形参列表)” 的使用，必须声明在子类构造器的首行。 在类的构造器中，针对于 “this(形参列表)” 或 “super(形参列表)”，只能二选一，不能同时出现。 在构造器的首行，如果没有显示的声明 “this(形参列表)” 或 “super(形参列表)”，则默认调用的是父类中空参的构造器，即：super();。 子类中所有的构造器默认都会访问父类中空参的构造器。 当父类中没有空参的构造器时，子类的构造器必须通过 “this(形参列表)” 或 “super(形参列表)” 语句，指定调用本类或者父类中相应的构造器。同时，只能二选一，且必须放在构造器的首行。 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错。 在类的多个构造器中，至少有一个类的构造器中使用了 “super(形参列表)”，调用父类中的构造器。 this 和 super 的区别： 区别点 this super 访问属性 访问本类中的属性，如果本类没有此属性，则从父类中继续查找 直接访问父类中的属性 调用方法 访问本类中的方法，如果本类没有此方法，则从父类中继续查找 直接访问父类中的方法 调用构造器 调用本类构造器，必须放在构造器的首行 调用父类构造器，必须放在子类构造器的首行 思考： 为什么 “super(形参列表)” 和 “this(形参列表)” 调用语句不能同时在一个构造器中出现？ 因为 “super(形参列表)” 和 “this(形参列表)” 调用语句都必须出现在构造器中的首行。 为什么 “super(形参列表)” 和 “this(形参列表)” 只能作为构造器中的第一句出现？ 因为无论通过哪个构造器创建子类对象，都需要保证先初始化父类。这样做的目的是：当子类继承父类后，可以获得父类中所有的属性和方法，这样子类就有必要在一开始就知道父类是如何为对象进行初始化。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Person &#123; String name; int age; int id = 1000; public Person() &#123; System.out.println(&quot;父类的空参构造器&quot;); &#125; public Person(String name, int age, int id) &#123; this.name = name; this.age = age; this.id = id; &#125; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep() &#123; System.out.println(&quot;睡觉&quot;); &#125;&#125;public class Student extends Person &#123; // String name;// 父类中已有的属性，可以省略 // int age;// 父类中已有的属性，可以省略 String major; int id = 1001; public Student() &#123; &#125; public Student(String name, int age, String major) &#123; this.name = name; this.age = age; this.major = major; &#125; // 父类中已有的方法，可以省略，如有需要，可以重写 // public void eat() &#123; // System.out.println(&quot;吃饭&quot;); // &#125; // 重写父类的方法 @Override public void sleep() &#123; System.out.println(&quot;学生睡觉&quot;); &#125; public void study() &#123; System.out.println(&quot;学习&quot;); &#125; public void show() &#123; System.out.println(&quot;子类中的id: &quot; + this.id);// this 可以省略，就近原则 System.out.println(&quot;父类中的id: &quot; + super.id);// 子类与父类有同名的属性 id，此时 super 不可以省略 &#125; public static void main(String[] args) &#123; Student student = new Student(); student.show(); &#125;&#125; static当编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过 new 关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。有时候，希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。例如：所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。 实例变量： 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; Circle c1 = new Circle(2.0); // c1.radius=2.0 Circle c2 = new Circle(3.0); // c2.radius=3.0 &#125;&#125; class Circle &#123; private double radius; public Circle(double radius) &#123; this.radius = radius; &#125; public double findArea() &#123; return Math.PI * radius * radius; &#125;&#125; 上述代码中，c1 的 radius 独立于 c2 的 radius，存储在不同的空间。c1 中的 radius 变化不会影响 c2 的 radius，反之亦然。 像 Circle 类中的变量 radius 这样的，叫实例变量 (instance variable)，它属于类的每一个对象，不能被同一个类的不同对象所共享。 如果想让一个类的所有实例共享数据，就用类变量。类变量的定义，就需要用到static关键字。 **static**： static：静态的。 static 可以用来修饰：属性、方法、代码块、内部类。 static 修饰后的成员具备以下特点： 随着类的加载而加载。 优先于对象存在。 修饰的成员，被所有对象所共享。 访问权限允许时，可不创建对象，直接被类调用。 使用 static 修饰属性：静态变量（类变量/class variable）。 属性，按是否使用 static 修饰，分为：静态属性和非静态属性（实例变量）。 实例变量：当创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象的非静态属性时，不会导致其他对象中同样的属性值被修改。 静态变量：当创建了类的多个对象，每个对象都共用同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改之后的值。 注意：实际操作时，虽然编译能通过，但不应该通过类的实例对象来访问静态成员。 静态变量随着类的加载而加载，可以通过&quot;类.静态变量&quot;的方式进行调用。 静态变量的加载要早于对象的创建。实例变量在创建对象的过程中，或创建对象之后，才创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：保存在方法区的静态域中。 类可以访问静态变量，但不能访问实例变量（实例变量在对象产生时才生成），对象可以访问实例变量，也能访问静态变量（不推荐）。 静态变量举例：System.out，Math.PI。 使用 static 修饰方法：静态方法（类方法/class method）。 静态方法随着类的加载而加载，可以通过&quot;类.静态方法&quot;的方式进行调用。 类可以访问静态方法，但不能访问非静态方法（非静态方法在对象产生时才生成），对象可以访问非静态方法，也能访问静态方法（不推荐）。 静态方法中，只能调用静态属性或静态方法，它们的生命周期是一致的。非静态方法中，既可以调用非静态属性或非静态方法，也能调用静态属性或静态方法。 static 使用的注意点： 在静态方法内，不能使用 this 关键字、super 关键字。（this 和 super 指向当前类对象和父类对象，需要创建实例对象后才有这些概念。） 123456// 方法见下面的示例public static void show() &#123; // 省略的是 Chiese.，而不是 this. walk();// 等同于 Chinese.walk(); System.out.println(&quot;nation: &quot; + nation);// 等同于 System.out.println(Chinese.nation);&#125; static 修饰的方法不能被重写。 关于静态属性和静态方法的使用，从生命周期的角度去理解。 类属性、类方法的设计思想： 类属性作为该类各个对象之间共享的变量，在设计类时，分析哪些属性不因对象的不同而改变，将这些属性设置为类属性，相应的方法设置为类方法。 如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。 类中的常量，通常也声明为 static 的。 操作静态属性的方法，通常设置为 static 的。 工具类中的方法，习惯上声明为 static 的。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Test &#123; public static void main(String[] args) &#123; Chinese c1 = new Chinese(); c1.name = &quot;姚明&quot;; c1.age = 40; Chinese c2 = new Chinese(); c2.name = &quot;马龙&quot;; c2.age = 30; // 通过 c1 对象修改 nation 的值，c2 对象也能获得 // 实际操作时，虽然编译能过通过，但不应该通过类的实例对象来访问静态成员 c1.nation = &quot;CHN&quot;; System.out.println(c2.nation); // 对象实例调用非静态方法 c1.eat(); // 类调用静态方法 Chinese.show(); // 通过 c1 对象也能调用非静态方法 // 实际操作时，虽然编译能过通过，但不应该通过类的实例对象来访问静态成员 c1.show(); &#125;&#125; class Chinese &#123; String name; int age; static String nation; public void eat() &#123; System.out.println(&quot;吃饭&quot;); // 调用非静态结构 this.info(); System.out.println(&quot;name: &quot; + this.name); // 调用静态结构 walk(); System.out.println(&quot;nation: &quot; + nation); &#125; public void info() &#123; System.out.println(&quot;name: &quot; + name + &quot;, age: &quot; + age + &quot;, nation: &quot; + nation); &#125; public static void show() &#123; System.out.println(&quot;我是中国人&quot;); // 不能调用非静态的结构 // eat(); // name = &quot;Tom&quot;; // 调用静态的结构 walk(); System.out.println(&quot;nation: &quot; + nation);// 省略的是Chiese.，而不是this.，等同于 System.out.println(Chinese.nation); &#125; public static void walk() &#123; System.out.println(&quot;走路&quot;); &#125;&#125; finalfinal： 理解为：最终的。 final 可以用来修饰：类、方法、变量（属性是成员变量，是变量的其中一种）。 final 用来修饰类：此类不能被其他类所继承。例如：String 类、System 类、StringBuffer 类。 12345678final class A &#123; &#125; // 错误，final 类不能被继承class B extends A &#123; &#125; final 用来修饰方法：此方法不能被子类重写。例如：Object 类中的 getClass()。 123456789101112class A &#123; public final void print() &#123; System.out.println(&quot;A&quot;); &#125;&#125; class B extends A &#123; // 错误，final 方法不能被子类重写 public final void print() &#123; System.out.println(&quot;A&quot;); &#125;&#125; final 用来修饰变量：此时的 &quot;变量&quot; 称为常量，名称大写，且只能被赋值一次。 1234567891011121314151617181920public final class Test &#123; public static int totalNumber = 5; public final int ID; public Test() &#123; // 可以在构造器中给 final 修饰的 &quot;变量&quot; 赋值 ID = ++totalNumber; &#125; public static void main(String[] args) &#123; Test t = new Test(); System.out.println(t.ID); final int I = 10; final int J; J = 20; // 非法 // J = 30; &#125;&#125; final 修饰成员变量：必须在声明时或代码块中或在每个构造器中显式赋值，否则编译不通过。 1234567891011121314151617181920212223242526public class FinalTest &#123; // 1. 显式初始化：所有对象的这个常量值都是相同的，可以考虑直接显式初始化 final int WIDTH = 0; // 2. 代码块中初始化：如果涉及到调用方法，或赋值操作较多，可以考虑代码块中初始化 final int HEIGHT; &#123; HEIGHT = show(); &#125; // 3. 构造器中初始化：如果涉及到调用方法，或赋值操作较多，可以考虑代码块中初始化 final int LEFT; public FinalTest() &#123; LEFT = show(); &#125; public int show() &#123; return 0; &#125; public static void main(String[] args) &#123; FinalTest finalTest = new FinalTest(); &#125;&#125; final 修饰局部变量：修饰方法内局部变量时，表明该变量是一个常量，不能被修改；修饰形参时，表明此形参是一个常量，当调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能被修改。 123456789101112131415161718public class FinalTest &#123; public int show() &#123; // 1. 修饰方法内局部变量：常量，不能被再次更改 final int NUM = 10; return NUM; &#125; // 2. 修饰形参：当方法被调用时，传入的实参，不能被再次更改 public void show(final int num) &#123; System.out.println(num); &#125; public static void main(String[] args) &#123; FinalTest finalTest = new FinalTest(); finalTest.show(20); &#125;&#125; static final用来修饰属性：全局常量。 12345678910111213141516171819202122public class FinalTest &#123; static final int WIDTH = 0; static final int HEIGHT; static &#123; HEIGHT = show(); &#125; public FinalTest() &#123; &#125; public static int show() &#123; return 0; &#125; public static void main(String[] args) &#123; FinalTest finalTest = new FinalTest(); &#125;&#125; 面试题： 123456789101112131415161718192021public class Something &#123; public int addOne(final int x) &#123; // return ++x;// 编译不通过 return x + 1;// 正常 &#125;&#125;public class Something &#123; public void addOne(final Other o) &#123; // o = new Other();// 编译不通过 o.i++;// 正常 &#125; public static void main(String[] args) &#123; Other o = new Other(); new Something().addOne(o); &#125;&#125; class Other &#123; public int i;&#125; package**package**：作为 Java 源文件的第一条语句，指明该文件中定义的类所在的包。若缺省该语句，则指定为无名包。 语法格式： 1package 顶层包名.子包名; 包对应于文件系统的目录，package 语句中，用.来指明包（目录）的层次。 包属于标识符，遵循标识符的命名规范，通常用小写单词标识。通常使用所在公司域名的倒置，如：com.zeloud.xxx。 同一个包下，不能命名同名的接口、类。不同的包下，可以命名同名的接口、类。 JDK 中主要的包： java.lang：包含一些 Java 语言的核心类，如 String、Math、Integer、 System 和 Thread，提供常用功能。 java.net：包含执行与网络相关的操作的类和接口。 java.io：包含能提供多种输入&#x2F;输出功能的类。 java.util：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text：包含了一些 Java 格式化相关的类。 java.sql：包含了 Java 进行 JDBC 数据库编程的相关类&#x2F;接口。 java.awt：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）。（B&#x2F;S 和 C&#x2F;S） import**import**：为使用定义在不同包中的 Java 类，需用 import 语句来引入指定包层次下所需要的类或全部类（.*）。import 语句告诉编译器到哪里去寻找类。 语法格式： 1import 包名.类名; 在源文件中使用 import 语句，可以显式的导入指定包下的类或接口。 声明在包的声明和类的声明之间。 如果需要导入多个类或接口，那么就并列显式声明多个 import 语句即可。 举例：可以使用 “import java.util.*;” 的方式，一次性导入 java.util 包下所有的类或接口。 如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import 语句。 如果在代码中使用不同包下的同名的类，那么使用时需要使用类的全类名的方式指明调用的是哪个类。 如果已经导入 java.a 包下的类，那么如果需要使用 a 包的子包下的类的话，仍然需要导入。 import static 组合的使用：导入指定类或接口下的静态的属性或方法。 1234567import static java.lang.System.*; public class Person &#123; public static void main(String[] args) &#123; out.println(&quot;打印方法&quot;);// 可以省略 System &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"探索性测试","slug":"探索性测试","date":"2024-12-20T01:50:49.000Z","updated":"2024-12-20T01:57:46.589Z","comments":true,"path":"2024/12/20/探索性测试/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/20/%E6%8E%A2%E7%B4%A2%E6%80%A7%E6%B5%8B%E8%AF%95/","excerpt":"一、什么是探索性测试探索性测试（Exploratory Testing）是一种软件测试方法，它强调测试人员在测试过程中同时设计测试、执行测试并学习系统的行为，与传统的脚本化测试不同，探索性测试不依赖于预先编写的详细测试用例，而是让测试人员根据他们对系统的理解和直觉来灵活地探索和测试软件的各个方面","text":"一、什么是探索性测试探索性测试（Exploratory Testing）是一种软件测试方法，它强调测试人员在测试过程中同时设计测试、执行测试并学习系统的行为，与传统的脚本化测试不同，探索性测试不依赖于预先编写的详细测试用例，而是让测试人员根据他们对系统的理解和直觉来灵活地探索和测试软件的各个方面 探索性测试将戴明环方法使用到了极致，它强调将测试相关学习、测试设计、测试执行和测试结果解读作为相互支持的活动，并行执行。其思维模型CPIE包括4个阶段： Collation（整理）：首先是测试相关学习，需要我们收集和整理被测产品的信息，并了解和理解它们。通常在这个阶段，我会翻开需求文档、方案文档看看，或者搜索之前的bug清单寻找思路 ※ Prioritization（排序）：进行测试设计，确定所有测试任务的优先级 ※ Investigation（调查）：对即将执行的测试任务进行仔细的分析并确定测试输入和预期输出，也属于测试设计的一部分 ※ Experimentation（实验）：重点在测试执行和对测试结果的验证，验证我们的预期是否正确，检查我们在整理阶段获取到的信息是否正确。根据实验结果，测试人员将收集更多的信息，并调整测试任务的优先级。以此不断达到收集反馈、调整测试、优化价值的效果。 二、探索性测试的典型方法根据不同产品的特性，可以将产品功能测试分成三个层次：单一功能特性测试、交互特性测试和系统交互测试。针对每个层次，探索性测试的方法可以简单的概括为：局部探索性测试方法、全局探索性测试法和混合探索性测试法。 在软件测试领域，针对产品的不同方面和层次，测试的种类和重点也有所不同。以下是对单一功能特性测试、交互特性测试和系统交互测试的详细解释： 1. 单一功能特性测试单一功能特性测试主要关注软件系统中某个具体功能的性能和正确性。这种测试的目的是验证单个功能是否按照设计需求正确实现，并且能够在预期的环境中稳定运行。测试人员会依据功能需求和设计文档，设计测试用例来检验功能的各个方面，包括输入、处理和输出是否符合预期。 例如，在一个电子邮件系统中，单一功能测试可能包括验证“发送邮件”功能是否能正确地将邮件发送至指定的收件人，邮件内容是否准确无误，以及附件是否能正常添加和发送等。 2. 交互特性测试交互特性测试侧重于评估软件界面的可用性、易用性和用户满意度。这种测试关注的是用户与软件界面交互时的体验，包括菜单、按钮、输入框等用户交互元素的布局、响应速度和准确性。测试人员会模拟用户操作，检查界面元素是否直观易用，交互流程是否顺畅，以及是否有任何可能导致用户困惑或操作失误的设计。 以智能手机为例，交互特性测试可能包括触控响应速度、滑动流畅度、手势识别准确度等方面的测试，以确保用户能够方便、快速地完成操作。 3. 系统交互测试系统交互测试旨在验证软件系统与其他系统或组件之间的交互是否正确无误。这种测试关注的是系统在不同环境下的兼容性、稳定性和性能表现。测试人员会检查系统在与外部实体（如其他软件系统、硬件设备或网络服务）交互时是否会出现问题，如数据丢失、性能下降或安全漏洞等。 例如，在一个企业资源规划（ERP）系统中，系统交互测试可能包括验证该系统是否能与财务系统、库存管理系统等其他企业应用无缝集成，以及在数据交换过程中是否会出现错误或延迟等问题。 综上所述，单一功能特性测试、交互特性测试和系统交互测试是软件测试中不可或缺的组成部分，它们分别从不同的角度和层次确保软件系统的质量、可用性和稳定性。 1、局部探索性测试方法我们首先会对软件的单一功能进行比较细致的探索式测试。“探索”的过程主要是基于功能需求以及非功能性需求进行扩展和延伸。 比如以软件系统的用户登录功能为例，作为探索式测试人员，首先应该站在最终用户的角度去理解和使用登录功能。为此，探索式测试人员需要分析出用户登录功能的所有原子输入项。假定原子输入项只有用户名、密码和登录按钮。接着组合这些原子输入项构成最基本典型的测试场景。 再比如，用真实合法的用户名以及密码完成登录就是一个非常基本典型的场景，如果该场景能够成功登录，就可以切换到下一个；如果该场景不能够成功登录，就需要去“探索”为什么没能登录成功，比如你可能会怀疑是否是因为用户名或者密码是区分大小写的，又或者是不是因为你多次错误的尝试而导致的。 基于你的怀疑，进一步去设计新的测试用例来验证你的猜测。总之，通过以上这样的“探索”过程，你将测试学习、测试设计、测试执行和测试结果评估串联成了一个快速迭代的过程，并在你脑海中快速建立了登录功能的详细模型。 2、全局探索性测试以用户登录功能为例，在系统交互的探索式测试中，就不仅要考虑单一的登录功能了，而是要考虑用户登录与系统其他功能相结合的场景。 比如，你可以尝试不登录直接访问登录后的路径去观察系统的行为；再比如，你可以尝试不登录就去查看订单状态的操作等等。这些组合场景的设计主要取决于你想要验证，或者说想要“探索”的系统功能。很多时候这些灵感来自于你之前对系统的探索而取得的系统认识，同时你的技术直觉也在此扮演了重要角色。 3、混合探索性测试混合探索性测试就是将探索性测试与传统的基于场景的测试方法相结合，通过引入变化达到系统交互测试的目的。 ![image-20241219151136172](&#x2F;Users&#x2F;zhangbijiang&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20241219151136172.png)","categories":[{"name":"测试","slug":"测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"工作方法","slug":"工作方法","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"效率","slug":"效率","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"番茄工作法图解","slug":"番茄工作法图解","date":"2024-12-01T09:30:46.000Z","updated":"2024-12-01T09:32:28.471Z","comments":true,"path":"2024/12/01/番茄工作法图解/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/12/01/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3/","excerpt":"番茄工作法是弗朗西斯科·西里洛在1992年创立的时间管理方法。 当时弗朗西斯科还是一名在校学生，他曾一度苦于学习效率低下的问题。后来他开始逼迫自己每次只坚持学习10分钟，甚至还用厨房定时器掐着时间进行。 这么一折腾，弗朗西斯科很快就发现自己的学习效率获得了大幅度提升，而当时他用的计时器，因外形酷似“番茄”，于是就把这种工作方法叫做“番茄工作法”。 而这本书的作者史蒂夫·诺特伯格，和发明人弗朗西斯科不同，他是这个番茄工作法的忠实实践者。","text":"番茄工作法是弗朗西斯科·西里洛在1992年创立的时间管理方法。 当时弗朗西斯科还是一名在校学生，他曾一度苦于学习效率低下的问题。后来他开始逼迫自己每次只坚持学习10分钟，甚至还用厨房定时器掐着时间进行。 这么一折腾，弗朗西斯科很快就发现自己的学习效率获得了大幅度提升，而当时他用的计时器，因外形酷似“番茄”，于是就把这种工作方法叫做“番茄工作法”。 而这本书的作者史蒂夫·诺特伯格，和发明人弗朗西斯科不同，他是这个番茄工作法的忠实实践者。 1、什么是番茄工作法说了这么多，可能有朋友会问，那到底什么是番茄工作法呢？ 用一句话表达，番茄工作法就是在25分钟番茄时间内只专注做一件事。 换而言之，就是在每天工作开始前，列出当天所有工作任务，并将这些工作任务分解成一个个25分钟的小任务，然后一项一项完成去它们。 我们把这个25分钟作为一个专注工作的基本时间单位，所以把这25分钟被称为一个“番茄钟”，这是番茄工作法最重要的核心要素之一。 所以番茄工作法的核心内容至少要有以下五点： （1）采用“专注25分钟工作+放松休息5分钟”的时间节律开展工作； （2）一次只做一件事； （3）番茄钟的执行过程中不可以中途停止，否则该番茄钟必须作废； （4）当你连续工作4个番茄钟时，可以得到一个20分钟的长休息； （5）通过“短时间的专注工作+频繁的休息奖励”，不断激励自己投入下一个工作任务，并逐渐喜欢上这种工作模式。 2、怎么使用番茄工作法（1）前期计划这里的前期计划，其实就是我们平时说的工作计划。 也就是说，我们通常所说的工作计划，只要列出一个工作清单就可以。但是番茄工作法，却要求至少要准备三张表格。 这三张表分别是：工作清单表、今日待办表和番茄跟踪记录表。 第一张表是工作清单表，说的就是我们平时的工作清单，你可以随时把近期的工作添加到这张表中，也可以把它从表中移出。 它就相当于一个大池塘，你要做的工作、领导安排的任务、同事需要协调的工作，都可以放进去，也可以移出去。也就是说，这个池塘里的“任务”的去留，你说了算。 第二张表是今日待办表，就是当天我们需要完成的工作。这些任务是从工作清单里面挑选出来的，而且挑选的原则是当前最重要的一项工作。 在这一天的工作中，每当你每完成一件工作，就划掉一项，直到把所有的任务划完为止。 第三张表，我们把它叫做番茄跟踪记录表。 为什么要用这张表呢？ 其实稍微动一下脑子就能立刻明白，这张表其实就是一个激励反馈信息表，无论是一项任务的预估番茄钟个数，还是实际的番茄钟个数都会在这张表上体现。 它不仅能够帮助我们及时、客观地反映番茄钟使用过程中存在的问题，及时发现自己时间管理上的问题，还能不断提升自己对时间的掌控力。 这是前期计划这个环节的三张表。 (2）中期执行第二个环节是中期执行。其实中期执行也很简单，只有三步： 第一，按照今日待办的所有工作任务，选择一项最重要的工作，作为当前马上要开展的工作； 第二，设定一个25分钟的计时器，作为你的专注工作的时间； 第三，专注工作25分钟之后，计时器响起，立刻放下手上的工作，休息5分钟。 这5分钟必须完全放下工作，你可以上厕所，接一杯水，或者做一个简单的运动项目，比如100次开合跳、50个原地高抬腿跑等等，总之，这5分钟你需要让大脑去真正休息一下，离开工位至少3米以外。 当然每完成一个番茄钟，要及时在番茄跟踪记录表中做记录，比如番茄钟进行中有多少次打断，一天当中有多少次非计划外的任务被添加进来，还有每项任务的预估番茄钟个数和实际番茄钟的个数存在的偏差等等。 然后就是不断重复循环。 当然你也可能会问，“25+5”这种模式会不会来回切换太频繁了，这样会不会更加降低工作效率呢？ 其实，这种方式是根据人类大脑自有的节律进行设置的。很多人一开始不适应是因为你的身体习惯了一件事做很久再休息的方式，而使用番茄工作法，改变了这个身体节律，所以产生了身体上的不适感，这并不是大脑不适应。 我们使用番茄工作法的目的是要提高我们大脑的工作效率，所以让身体的节律和大脑保持一致，才是持续高效工作的原始密码。 （3）后期评估 最后一个环节是后期评估。 一天的工作结束了，这时候我们需要花上5分钟时间，复盘一下自己一天的番茄跟踪记录情况。 首先，要把自己早上预估番茄钟的个数，和实际一天真实的番茄钟个数进行对比。 通过这样的方法，来看看自己对时间把控情况，哪些工作预估比较准确，哪些工作的预估还是存在比较大的偏差？不断找原因，找差距，寻找更好的方法来解决这些问题，不断地提升自己对时间的管控感。 然后，还要看看自己一天的番茄标记有多少？如有多少次的打断？有多少项计划外工作？通过分析“番茄跟踪记录”，判断自己有哪些提升？还存在哪些问题？ 3、工作被中断怎么办（1）内部中断 我们先看第一种中断——内部中断。 作者提出了一个明确的策略，那就是首先接受它，然后把它可视化，也就是把它记录下来，然后立即继续你手头的工作，避免真的被中断。 这个时候，我们再回过头想一想，在前期计划里的三张表：工作清单表、今日待办表和番茄跟踪记录表，是不是立刻明白了这三张表的重要性？ 没错，这个时候突然萌发的工作，如果不是很重要或者很紧急，那就先把它罗列在你的工作清单表中，这样你手上的工作就不会被中断，而且这项工作也不会被遗忘掉。 （2）外部中断 还有一种中断叫外部中断，也就是被他人打断自己的工作。 作者在书里也明确提出了一种处理策略，具体分四步： 第一步：告知 你需要先告知对方，“我手头有事，正忙。” 先保护好自己现有的番茄钟。 这种情况下，中断你工作的人，有一部分就会转向他人。当然还有一些人会继续选择向你求助，那么你就可以启动第二步。 第二步：协商 这一步你需要告诉对方一个准确的时间，比如“周五我再帮你做，你看行吗？” 如果对方不能接受，他就需要另想其他办法了。 如果对方接受，那你就需要继续启动第三步，并且现在立刻把这项工作列入你的工作清单表中。 第三步：列计划 第三步就是，把这项计划外的工作列入你的工作清单当中，并为它预估一个番茄钟个数。 第四步：答复 最后一步就是，在你完成这项工作后，需要及时给对方一个回复，用于增加他对你的信任程度，不然的话，在以后的工作中，你就很难再得到信任了。 以上就是这本书的全部精华内容。最后，我们总结一下： 1、番茄工作法的核心内容就是在25分钟番茄时间内只专注做一件事。 一旦25分钟的专注工作时间到了，就需要休息5分钟，中途也不可以停止。当你连续完成4个番茄钟的时候，可以获得一个更长时间的休息，也就是20分钟的长休息时间。 通过这种“短时间的专注工作+频繁的休息奖励”的方式，不断激励自己投入下一个工作任务当中，并逐渐喜欢上这种工作方式。 2、番茄工作法具体使用有三个环节：前期计划、中期执行和后期评估。 前期计划需要准备三张表格，它们分别是工作清单表、今日待办表以及番茄跟踪记录表。 中期执行也是分三步。第一步，按照今日待办的所有工作任务，选择一项最重要的工作，作为当前马上要开展的工作；第二步，设定一个25分钟的计时器，作为你的专注工作的时间；第三步，专注工作25分钟之后，计时器响起，立刻放下手上的工作，休息5分钟。 后期评估环节也有两个步骤：首先，要把预估番茄钟和实际番茄钟的个数进行对比，找到自己的不足和差距。同时还要结合自己的番茄记录，了解自己一天有多少次的中断？有多少项计划外工作？找到自己的问题以及短板，为自己的能力提升找到一个明确的方向。 3、在具体工作中如果被中断也有两个策略。 面对内部中断，首先是接受它，然后把它可视化，也就是把它记录下来，然后立即继续你手头的工作。 面对外部打断，可以分四步走： 第一步：告知对方，自己正在忙； 第二步：与对方协商一个新的工作时间； 第三步：把这项计划外的工作列入你的工作清单中。 第四步：在完成这项计划外工作的时候，需要按照承诺给对方一个明确的回复。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"工作方法","slug":"工作方法","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"效率","slug":"效率","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"数据迁移测试","slug":"数据迁移测试","date":"2024-11-22T02:27:23.000Z","updated":"2024-11-22T04:10:05.535Z","comments":true,"path":"2024/11/22/数据迁移测试/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2024/11/22/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%B5%8B%E8%AF%95/","excerpt":"数据迁移主要是在新老系统切换的时候，主要是以下新、两种 将老系统中的数据全部迁移到新系统，业务上只使用新系统，不再使用老系统 老系统的某些功能暂时无法实现，但是要在业务中使用新系统，这时候新老系统都需要使用，老系统产生的数据需要增量同步到新系统的数据库中","text":"数据迁移主要是在新老系统切换的时候，主要是以下新、两种 将老系统中的数据全部迁移到新系统，业务上只使用新系统，不再使用老系统 老系统的某些功能暂时无法实现，但是要在业务中使用新系统，这时候新老系统都需要使用，老系统产生的数据需要增量同步到新系统的数据库中 一、数据迁移的风险1、需要确认数据规模，这次迁移的数据量，线上数据库那么如果按照顺序迁移，则可能花费几个月甚至几年的时间。 2、迁移过程中服务是否需要停止， 因为不能在迁移过程中中断或者停止所有或部分服务，那么在这个迁移过程中必须要保证服务100%处于可用状态。 3、保证数据的，正确性，一致性，可用性，在数据迁移过程中，必须确保每项服务获取到的数据都是正确无误 二、数据迁移前的准备工作在进行数据迁移前需要和开发、产品、运维等确认好数据的迁移范围 在进行测试之前，需要对核心的测试点做重点的梳理，其中主要包括本次迁移涉及到的后端接口、对应的数据库表以及数据迁移的接口 涉及到了4个库7张表，关系复杂，需要验证的数据内容较多，针对性的列出了对应场景和表表直接关系，以及一些细节关注点 三、迁移数据的方法1、直接复制表 将原有系统数据库中的表直接复制到新系统的数据库中； 2、拆表&amp;合表 拆表：将原有系统数据库中的表数据拆分到新系统数据库中的几张表中； 合表：将原有系统数据库中的表字段合并到新系统数据库中的一张表中； PS：需要确认清楚，哪些表分拆迁移，哪些表合并迁移，迁移的数据字段、条数等！ 1.3：数据迁移接口及数据校验接口 四、数据迁移测试1、数据量一致性测试 要做到新老系统无缝切换，就必须保证数据的正确性和一致性，首要条件就是迁移的数据量是保持一致的，否则无法进行其他测试。 方法：①、可以通过文本统计工具或者数据库连接工具将迁移前的数据库表名、字段、数量等进行统计，然后将迁移后的新数据库表名、字段、数量等进行统计，然后进行比较。 ②、通过MD5生成工具，对新老数据文本进行MD5值比对测试，如果一致则表示数据量一致，如果不一致，则表明迁移后的数据有部分存在问题。 2、数据库表结构变化测试 这种测试分2种情况：一种是新老数据库表结构完全不存在关系，新数据库表的字段都是给定的默认值；还有一种是新数据库表字段是由原有系统数据库表字段转换而来。 方法：针对第一种情况，因为新增的字段都是给定的默认值，所以只需要根据开发提供的填写规则，检查该字段的所有值是否满足填写规则。 针对第二种情况，可以通过编写自动化测试脚本或者人工抽样或者切片方式进行，具体的抽样选择根据数据量等具体情况选择合适的比例即可。 五、业务逻辑测试完成上面的数据迁移测试后，需要在新的系统中进行回归测试，以确保迁移过来的数据是100%可用的。 回归测试前需要和业务、开发确认哪些业务模块涉及了哪些表，然后根据具体情况，尽可能的提高测试用例覆盖率，做一次全系统的功能回归测试（可以考虑自动化测试来替代一部分手工测试）。","categories":[{"name":"测试","slug":"测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"数据迁移","slug":"数据迁移","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"}]},{"title":"Httprunner源码解读(3)client.py","slug":"Httprunner源码解读-3-client-py","date":"2023-06-12T02:38:38.000Z","updated":"2024-11-22T04:11:09.161Z","comments":true,"path":"2023/06/12/Httprunner源码解读-3-client-py/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/06/12/Httprunner%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-3-client-py/","excerpt":"client.py的代码结构这个模块中定义了2个类和1个方法 ApiResponse类1234567891011class ApiResponse(Response): &quot;&quot;&quot; 继承Response 类，重写了raise_for_status方法，用于检查响应是否包含错误信息，并在响应中包含错误信息时抛出相应的异常 raise_for_status 方法首先检查响应对象是否包含 error 属性，并且该属性的值不为 None。如果 error 属性存在且不为 None，则抛出 error 异常。 否则，调用父类 Response 的 raise_for_status 方法，检查响应的状态码是否为 4xx 或 5xx，如果是，则抛出相应的异常。 &quot;&quot;&quot; def raise_for_status(self): if hasattr(self, &quot;error&quot;) and self.error: raise self.error Response.raise_for_status(self)","text":"client.py的代码结构这个模块中定义了2个类和1个方法 ApiResponse类1234567891011class ApiResponse(Response): &quot;&quot;&quot; 继承Response 类，重写了raise_for_status方法，用于检查响应是否包含错误信息，并在响应中包含错误信息时抛出相应的异常 raise_for_status 方法首先检查响应对象是否包含 error 属性，并且该属性的值不为 None。如果 error 属性存在且不为 None，则抛出 error 异常。 否则，调用父类 Response 的 raise_for_status 方法，检查响应的状态码是否为 4xx 或 5xx，如果是，则抛出相应的异常。 &quot;&quot;&quot; def raise_for_status(self): if hasattr(self, &quot;error&quot;) and self.error: raise self.error Response.raise_for_status(self) get_req_resp_record方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283def get_req_resp_record(resp_obj: Response) -&gt; ReqRespData: &quot;&quot;&quot;get request and response info from Response() object.&quot;&quot;&quot;# 定义了一个打印日志的函数，将打印的日志解析为标准的json格式 def log_print(req_or_resp, r_type): msg = f&quot;\\n================== &#123;r_type&#125; details ==================\\n&quot; for key, value in req_or_resp.dict().items(): if isinstance(value, dict) or isinstance(value, list): value = json.dumps(value, indent=4, ensure_ascii=False) msg += &quot;&#123;:&lt;8&#125; : &#123;&#125;\\n&quot;.format(key, value) logger.debug(msg) # record actual request info # 是先获取request_headers、request_cookies、request_body，然后将获取到的信息放入RequestData模型中，最后打印请求的信息 request_headers = dict(resp_obj.request.headers) request_cookies = resp_obj.request._cookies.get_dict() request_body = resp_obj.request.body if request_body is not None: try: request_body = json.loads(request_body) except json.JSONDecodeError: # str: a=1&amp;b=2 pass except UnicodeDecodeError: # bytes/bytearray: request body in protobuf pass except TypeError: # neither str nor bytes/bytearray, e.g. &lt;MultipartEncoder&gt; pass request_content_type = lower_dict_keys(request_headers).get(&quot;content-type&quot;) if request_content_type and &quot;multipart/form-data&quot; in request_content_type: # upload file type request_body = &quot;upload file stream (OMITTED)&quot; request_data = RequestData( method=resp_obj.request.method, url=resp_obj.request.url, headers=request_headers, cookies=request_cookies, body=request_body, ) # log request details in debug mode log_print(request_data, &quot;request&quot;) # record response info # 获取resp_headers、content_type、response_body，最后将这些数据都放入ResponseData模型类中，最后打印响应日志 resp_headers = dict(resp_obj.headers) lower_resp_headers = lower_dict_keys(resp_headers) content_type = lower_resp_headers.get(&quot;content-type&quot;, &quot;&quot;) if &quot;image&quot; in content_type: # response is image type, record bytes content only response_body = resp_obj.content else: try: # try to record json data response_body = resp_obj.json() except ValueError: # only record at most 512 text charactors resp_text = resp_obj.text response_body = omit_long_data(resp_text) response_data = ResponseData( status_code=resp_obj.status_code, cookies=resp_obj.cookies or &#123;&#125;, encoding=resp_obj.encoding, headers=resp_headers, content_type=content_type, body=response_body, ) # log response details in debug mode log_print(response_data, &quot;response&quot;) # 请求信息和响应信息全部放入ReqRespData模型中，最后get_req_resp_record函数返回的内容就是ReqRespData模型req_resp_data = ReqRespData(request=request_data, response=response_data) return req_resp_data HttpSession类HttpSession 是一个用于执行 HTTP 请求的类，它继承自 requests.Session 类，并扩展了一些功能。HttpSession 类的主要作用是在发送 HTTP 请求时记录请求和响应的信息，以便后续进行统计和分析 123def __init__(self): super(HttpSession, self).__init__() self.data = SessionData() 初始化方法，定义了data属性的默认值为SessionData模型，该模型包含了req_resps: List[ReqRespData] &#x3D; []请求响应内容 1234567def update_last_req_resp_record(self, resp_obj): &quot;&quot;&quot; update request and response info from Response() object. &quot;&quot;&quot; # TODO: fix self.data.req_resps.pop() self.data.req_resps.append(get_req_resp_record(resp_obj)) update_last_req_resp_record 方法用于更新最后一次请求和响应的信息，该方法会从 Response 对象中提取请求和响应的信息，并更新到 SessionData 对象中 123456789101112131415def _send_request_safe_mode(self, method, url, **kwargs): &quot;&quot;&quot; Send a HTTP request, and catch any exception that might occur due to connection problems. Safe mode has been removed from requests 1.x. &quot;&quot;&quot; try: return requests.Session.request(self, method, url, **kwargs) except (MissingSchema, InvalidSchema, InvalidURL): raise except RequestException as ex: resp = ApiResponse() resp.error = ex resp.status_code = 0 # with this status_code, content returns None resp.request = Request(method, url).prepare() return resp _send_request_safe_mode 方法用于发送 HTTP 请求，并捕获可能发生的连接问题异常。如果发送请求时发生异常，则返回一个 ApiResponse 对象，该对象包含了异常信息和请求对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293def request(self, method, url, name=None, **kwargs): &quot;&quot;&quot; Constructs and sends a :py:class:`requests.Request`. Returns :py:class:`requests.Response` object. :param method: method for the new :class:`Request` object. :param url: URL for the new :class:`Request` object. :param name: (optional) Placeholder, make compatible with Locust&#x27;s HttpSession :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`. :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`. :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`. :param files: (optional) Dictionary of ``&#x27;filename&#x27;: file-like-objects`` for multipart encoding upload. :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth. :param timeout: (optional) How long to wait for the server to send data before giving up, as a float, or \\ a (`connect timeout, read timeout &lt;user/advanced.html#timeouts&gt;`_) tuple. :type timeout: float or tuple :param allow_redirects: (optional) Set to True by default. :type allow_redirects: bool :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy. :param stream: (optional) whether to immediately download the response content. Defaults to ``False``. :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided. :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, (&#x27;cert&#x27;, &#x27;key&#x27;) pair. &quot;&quot;&quot; self.data = SessionData() # timeout default to 120 seconds kwargs.setdefault(&quot;timeout&quot;, 120) # set stream to True, in order to get client/server IP/Port kwargs[&quot;stream&quot;] = True start_timestamp = time.time() response = self._send_request_safe_mode(method, url, **kwargs) response_time_ms = round((time.time() - start_timestamp) * 1000, 2) try: client_ip, client_port = response.raw._connection.sock.getsockname() self.data.address.client_ip = client_ip self.data.address.client_port = client_port logger.debug(f&quot;client IP: &#123;client_ip&#125;, Port: &#123;client_port&#125;&quot;) except Exception: pass try: server_ip, server_port = response.raw._connection.sock.getpeername() self.data.address.server_ip = server_ip self.data.address.server_port = server_port logger.debug(f&quot;server IP: &#123;server_ip&#125;, Port: &#123;server_port&#125;&quot;) except Exception: pass # get length of the response content content_size = int(dict(response.headers).get(&quot;content-length&quot;) or 0) # record the consumed time self.data.stat.response_time_ms = response_time_ms self.data.stat.elapsed_ms = response.elapsed.microseconds / 1000.0 self.data.stat.content_size = content_size # record request and response histories, include 30X redirection response_list = response.history + [response] self.data.req_resps = [ get_req_resp_record(resp_obj) for resp_obj in response_list ] try: response.raise_for_status() except RequestException as ex: logger.error(f&quot;&#123;str(ex)&#125;&quot;) else: logger.info( f&quot;status_code: &#123;response.status_code&#125;, &quot; f&quot;response_time(ms): &#123;response_time_ms&#125; ms, &quot; f&quot;response_length: &#123;content_size&#125; bytes&quot; ) return response 最重要的 request 方法。request 方法用于构造并发送一个 HTTP 请求，并返回一个 requests.Response 对象。在发送请求之前，request 方法会先清空之前的请求和响应信息，然后设置一些默认参数，如超时时间、是否允许重定向等。接着，request 方法会调用 _send_request_safe_mode 方法发送请求，并记录请求和响应的信息。最后，request 方法会检查响应的状态码是否为 4xx 或 5xx，如果是，则抛出相应的异常。主要做了以下事情 设置了超时时间120s 计算整个请求花费了多少时间 定义了客户端ip地址和端口号、服务端ip地址和端口号 计算了响应体的内容大小 记录了消耗时间 记录了request和response记录，包括重定向记录","categories":[{"name":"Httprunner","slug":"Httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Httprunner/"}],"tags":[{"name":"httprunner","slug":"httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Httprunner源码解读(2)models.py","slug":"Httprunner源码解读-2-models-py","date":"2023-06-11T10:18:24.000Z","updated":"2024-11-22T04:11:03.405Z","comments":true,"path":"2023/06/11/Httprunner源码解读-2-models-py/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/06/11/Httprunner%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-2-models-py/","excerpt":"models.py的代码结构这个模块中定义了12个属性和29个模型类文件主要包含了一系列用于描述测试配置、请求和响应的数据模型类。这些数据模型通常继承自 Pydantic’s BaseModel 类，它们用于实现类型检查、数据验证以及序列化和反序列化等功能。","text":"models.py的代码结构这个模块中定义了12个属性和29个模型类文件主要包含了一系列用于描述测试配置、请求和响应的数据模型类。这些数据模型通常继承自 Pydantic’s BaseModel 类，它们用于实现类型检查、数据验证以及序列化和反序列化等功能。 models.py 中的数据模型提供了以下几个方面的功能： 定义测试用例的数据结构：通过创建数据模型来表示测试用例的各个组成部分，如配置、请求、响应和变量等。 类型检查和数据验证：利用 Pydantic 提供的类型检查和验证机制，确保从 YAML&#x2F;JSON 测试用例文件中加载的数据符合预期格式和约束。 序列化与反序列化：Pydantic 数据模型可以轻松地将 Python 对象转换为 JSON 格式，或者将 JSON 数据反序列化为 Python 对象。 总的来说，models.py 文件对 HttpRunner 的整个测试流程提供了结构支持，确保了测试用例以一种结构化、可靠且易于解析的方式进行编写和执行。通过使用这些数据模型，HttpRunner 可以更容易地处理、验证和操作来自测试用例文件的数据。 BaseModel 是一个pydantic的基础类，用于数据验证和序列化。它的作用主要包括： 类型检查：确保输入数据符合预期类型。 数据验证：根据模型中定义的限制条件对输入数据进行验证。 默认值设置：自动为缺失字段提供默认值。 序列化与反序列化：将 Python 对象转换为 JSON 格式，以及从 JSON 转换回 Python 对象。 通过继承 BaseModel 并定义字段，用户可以轻松构建自己的数据模型。这有助于减少代码错误、提高数据质量和简化数据处理流程。 属性源码分析123456789101112131415161718192021222324import osfrom enum import Enumfrom typing import Any, Callable, Dict, List, Text, Unionfrom pydantic import BaseModel, Field, HttpUrl&quot;&quot;&quot;Text =&gt; str / 文本List =&gt; list / 列表Dict =&gt; dict / 字典&quot;&quot;&quot;Name = TextUrl = TextBaseUrl = Union[HttpUrl, Text]VariablesMapping = Dict[Text, Any]FunctionsMapping = Dict[Text, Callable]Headers = Dict[Text, Text]Cookies = Dict[Text, Text]Verify = boolHooks = List[Union[Text, Dict[Text, Text]]]Export = List[Text]Validators = List[Dict]Env = Dict[Text, Any] 用到了typing和pydantic模块，定义了这些属性的类型 模型类源码分析MethodEnum1234567891011class MethodEnum(Text, Enum): &quot;&quot;&quot; 内置枚举类，常用请求的方式 &quot;&quot;&quot; GET = &quot;GET&quot; POST = &quot;POST&quot; PUT = &quot;PUT&quot; DELETE = &quot;DELETE&quot; HEAD = &quot;HEAD&quot; OPTIONS = &quot;OPTIONS&quot; PATCH = &quot;PATCH&quot; ProtoType12345678class ProtoType(Enum): &quot;&quot;&quot; 内置枚举类，请求数据类型 &quot;&quot;&quot; Binary = 1 CyBinary = 2 Compact = 3 Json = 4 TransType12345678class ProtoType(Enum): &quot;&quot;&quot; 内置枚举类，请求数据类型 &quot;&quot;&quot; Binary = 1 CyBinary = 2 Compact = 3 Json = 4 TransType12345678class TransType(Enum): &quot;&quot;&quot; 内置枚举类，它定义了 thrift 协议中数据传输类型 &quot;&quot;&quot; Buffered = 1 CyBuffered = 2 Framed = 3 CyFramed = 4 TConfigThrift123456789101112131415161718class TConfigThrift(BaseModel): &quot;&quot;&quot; 内置枚举类, 定义TConfigThrift 的数据模型 &quot;&quot;&quot; psm: Text = None env: Text = None cluster: Text = None target: Text = None include_dirs: List[Text] = None thrift_client: Any = None timeout: int = 10 idl_path: Text = None method: Text = None ip: Text = &quot;127.0.0.1&quot; port: int = 9000 service_name: Text = None proto_type: ProtoType = ProtoType.Binary trans_type: TransType = TransType.Buffered TConfigDB12345678910class TConfigDB(BaseModel): &quot;&quot;&quot; 内置枚举类, 定义用于存储与数据库相关的配置信息 &quot;&quot;&quot; psm: Text = None user: Text = None password: Text = None ip: Text = None port: int = 3306 database: Text = None TransportEnum1234567class TransportEnum(Text, Enum): &quot;&quot;&quot; 内置枚举类,继承自 Text 和 Enum。它定义了两个枚举值：BUFFERED 和 FRAMED，分别表示缓冲传输和帧传输。枚举值的类型是 Text， 因此它们可以是任何字符串。枚举类的作用是为 HttpRunner 提供传输类型的选择 &quot;&quot;&quot; BUFFERED = &quot;buffered&quot; FRAMED = &quot;framed&quot; TThriftRequest1234567891011121314151617181920212223class TThriftRequest(BaseModel): &quot;&quot;&quot; rpc request model 内置枚举类，它继承自 BaseModel。它定义了一些属性，用于表示 Thrift 请求的相关信息，包括方法名、参数、Thrift 客户端、IDL 文件路径、 超时时间、传输类型、目标地址、环境、集群、PSM、服务名、IP、端口、协议类型和传输类型等。这些属性都有默认值，可以通过实例化对象来设置它们的值 &quot;&quot;&quot; method: Text = &quot;&quot; params: Dict = &#123;&#125; thrift_client: Any = None idl_path: Text = &quot;&quot; # idl local path timeout: int = 10 # sec transport: TransportEnum = TransportEnum.BUFFERED include_dirs: List[Union[Text, None]] = [] # param of thriftpy2.load target: Text = &quot;&quot; # tcp://&#123;ip&#125;:&#123;port&#125; or sd://psm?cluster=xx&amp;env=xx env: Text = &quot;prod&quot; cluster: Text = &quot;default&quot; psm: Text = &quot;&quot; service_name: Text = None ip: Text = None port: int = None proto_type: ProtoType = None trans_type: TransType = None SqlMethodEnum1234567891011class SqlMethodEnum(Text, Enum): &quot;&quot;&quot; 内置枚举类，它继承自 Text 和 Enum。它定义了一些枚举值，用于表示 SQL 操作的类型，包括 FETCHONE、FETCHMANY、FETCHALL、INSERT、UPDATE 和 DELETE。 这些枚举值可以通过实例化对象来访问，以执行相应的 SQL 操作 &quot;&quot;&quot; FETCHONE = &quot;FETCHONE&quot; FETCHMANY = &quot;FETCHMANY&quot; FETCHALL = &quot;FETCHALL&quot; INSERT = &quot;INSERT&quot; UPDATE = &quot;UPDATE&quot; DELETE = &quot;DELETE&quot; TSqlRequest123456789101112class TSqlRequest(BaseModel): &quot;&quot;&quot; sql request model 内置枚举类, 它继承自 BaseModel。它定义了一些属性，用于表示 SQL 请求的相关信息，包括数据库配置、SQL 操作类型、SQL 语句和结果集大小等。其中，db_config 属性表示数据库配置信息， 它是一个 TConfigDB 类型的对象，包括 PSM、用户名、密码、IP、端口和数据库名等。method 属性表示 SQL 操作类型，它是一个 SqlMethodEnum 类型的枚举值，包括 FETCHONE、FETCHMANY、FETCHALL、 INSERT、UPDATE 和 DELETE。sql 属性表示 SQL 语句，size 属性表示结果集大小，用于限制 SQL 查询结果的数量。 &quot;&quot;&quot; db_config: TConfigDB = TConfigDB() method: SqlMethodEnum = None sql: Text = None size: int = 0 # limit nums of sql result TConfig1234567891011121314151617181920212223242526class TConfig(BaseModel): &quot;&quot;&quot; 内置枚举类 它定义了一些属性，用于表示 HttpRunner 的配置信息，包括名称、验证、基础 URL、变量、参数、导出变量、路径、Thrift 配置和数据库配置等。 其中，name 属性表示配置对象的名称， verify 属性表示是否验证 SSL 证书， base_url 属性表示基础 URL， variables 属性表示变量，可以是一个字典或者是一个字符串，字符串表示变量的 Python 代码， parameters 属性表示参数，可以是一个字典或者是一个字符串，字符串表示参数的 Python 代码，export 属性表示导出变量的名称列表， path 属性表示配置文件的路径， thrift 属性表示 Thrift 配置信息，是一个 TConfigThrift 类型的对象， db 属性表示数据库配置信息，是一个 TConfigDB 类型的对象。 &quot;&quot;&quot; name: Name verify: Verify = False base_url: BaseUrl = &quot;&quot; # Text: prepare variables in debugtalk.py, $&#123;gen_variables()&#125; variables: Union[VariablesMapping, Text] = &#123;&#125; parameters: Union[VariablesMapping, Text] = &#123;&#125; # setup_hooks: Hooks = [] # teardown_hooks: Hooks = [] export: Export = [] path: Text = None # configs for other protocols thrift: TConfigThrift = None db: TConfigDB = TConfigDB() TRequest12345678910111213141516171819202122232425262728class TRequest(BaseModel): &quot;&quot;&quot; requests.Request model 内置枚举类 它继承自 BaseModel。它定义了一些属性，用于表示 HTTP 请求的相关信息，包括请求方法、URL、查询参数、请求头、请求体、数据、超时时间、重定向、SSL 验证和上传文件等。 method 属性表示请求方法，它是一个 MethodEnum 类型的枚举值，包括 GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH 和 TRACE。 url 属性表示请求的 URL， params 属性表示查询参数，headers 属性表示请求头， req_json 属性表示请求体，可以是一个字典、列表或者字符串，字符串表示请求体的 JSON 格式的字符串， data 属性表示请求数据，可以是一个字典或者字符串，字符串表示请求数据的 Python 代码， cookies 属性表示请求的 cookies， timeout 属性表示超时时间， allow_redirects 属性表示是否允许重定向， verify 属性表示是否验证 SSL 证书， upload 属性表示上传文件的信息，是一个字典，包括文件名、文件路径和文件类型等。 &quot;&quot;&quot; method: MethodEnum url: Url params: Dict[Text, Text] = &#123;&#125; headers: Headers = &#123;&#125; req_json: Union[Dict, List, Text] = Field(None, alias=&quot;json&quot;) data: Union[Text, Dict[Text, Any]] = None cookies: Cookies = &#123;&#125; timeout: float = 120 allow_redirects: bool = True verify: Verify = False upload: Dict = &#123;&#125; # used for upload files TStep1234567891011121314151617181920212223242526272829303132class TStep(BaseModel): &quot;&quot;&quot; 测试步骤，里面包含了request请求 它继承自 BaseModel。它定义了一些属性，用于表示测试步骤的相关信息，包括名称、请求、测试用例、变量、setup 和 teardown 钩子、提取变量、导出变量、验证器、验证脚本、重试次数、重试间隔、Thrift 请求和 SQL 请求等。 其中，name 属性表示测试步骤的名称， request 属性表示 HTTP 请求的相关信息，是一个 TRequest 类型的对象， testcase 属性表示测试用例，可以是一个字符串或者是一个函数，字符串表示测试用例的 Python 代码，函数表示测试用例的函数对象， variables 属性表示变量，是一个字典，setup_hooks 属性表示 setup 钩子，是一个列表，列表中的元素可以是字符串或者是函数，字符串表示 setup 钩子的 Python 代码，函数表示 setup 钩子的函数对象，t eardown_hooks 属性表示 teardown 钩子，是一个列表，列表中的元素可以是字符串或者是函数，字符串表示 teardown 钩子的 Python 代码，函数表示 teardown 钩子的函数对象， extract 属性表示提取变量，是一个字典，export 属性表示导出变量，是一个列表，列表中的元素是字符串，表示要导出的变量名， validators 属性表示验证器，是一个列表，列表中的元素是一个字典，表示验证器的相关信息，validate_script 属性表示验证脚本，是一个列表，列表中的元素是字符串，表示验证脚本的 Python 代码， retry_times 属性表示重试次数， retry_interval 属性表示重试间隔， thrift_request 属性表示 Thrift 请求的相关信息，是一个 TThriftRequest 类型的对象， sql_request 属性表示 SQL 请求的相关信息，是一个 TSqlRequest 类型的对象。 &quot;&quot;&quot; name: Name request: Union[TRequest, None] = None testcase: Union[Text, Callable, None] = None variables: VariablesMapping = &#123;&#125; setup_hooks: Hooks = [] teardown_hooks: Hooks = [] # used to extract request&#x27;s response field extract: VariablesMapping = &#123;&#125; # used to export session variables from referenced testcase export: Export = [] validators: Validators = Field([], alias=&quot;validate&quot;) validate_script: List[Text] = [] retry_times: int = 0 retry_interval: int = 0 # sec thrift_request: Union[TThriftRequest, None] = None sql_request: Union[TSqlRequest, None] = None 这个类的作用是定义测试步骤的相关信息，方便用户进行接口测试。用户可以通过实例化对象来设置这些属性的值，然后将对象传递给 HttpRunner 类的相应方法，以执行相应的接口测试。在执行接口测试之前，用户需要先创建一个 HttpRunner 对象，并将配置信息传递给它。然后，用户可以通过调用 HttpRunner 对象的相应方法，传递 TStep 对象作为参数，来执行相应的接口测试。在执行测试步骤之前，用户需要先创建一个 TRequest 对象，并将 HTTP 请求的相关信息传递给它。然后，用户可以通过设置 TStep 对象的 request 属性，将 TRequest 对象作为参数传递给它，来定义测试步骤的 HTTP 请求。如果用户需要在测试步骤中执行测试用例，可以将测试用例的 Python 代码或者函数对象作为参数传递给 TStep 对象的 testcase 属性。如果用户需要在测试步骤中执行 setup 或 teardown 钩子，可以将钩子的Python 代码或者函数对象作为参数传递给 TStep 对象的 setup_hooks 或 teardown_hooks 属性。如果用户需要在测试步骤中提取变量，可以将变量名和提取规则作为参数传递给TStep 对象的 extract 属性。如果用户需要在测试步骤中导出变量，可以将变量名作为参数传递给 TStep 对象的 export 属性。如果用户需要在测试步骤中执行验证器，可以将验证器的相关信息作为参数传递给 TStep 对象的 validators 属性。如果用户需要在测试步骤中执行验证脚本，可以将验证脚本的 Python 代码作为参数传递给 TStep 对象的 validate_script 属性。如果用户需要在测试步骤中执行重试操作，可以将重试次数和重试间隔作为参数传递给 TStep 对象的 retry_times 和 retry_interval 属性。如果用户需要在测试步骤中执行 Thrift 请求，可以将 Thrift 请求的相关信息作为参数传递给 TStep 对象的 thrift_request 属性。如果用户需要在测试步骤中执行 SQL 请求，可以将 SQL 请求的相关信息作为参数传递给 TStep 对象的 sql_request 属性。 TestCase123456789class TestCase(BaseModel): &quot;&quot;&quot; 测试用例，包含了测试步骤和配置信息 它定义了一些属性，用于表示测试用例的相关信息，包括配置信息和测试步骤等。 config 属性表示配置信息，是一个 TConfig 类型的对象， teststeps 属性表示测试步骤，是一个 TStep 类型的对象的列表。 &quot;&quot;&quot; config: TConfig teststeps: List[TStep] ProjectMeta1234567891011121314151617181920class ProjectMeta(BaseModel): &quot;&quot;&quot; 项目结构 定义了一些属性，用于表示项目的相关信息， debugtalk.py 文件的内容和路径、.env 文件的路径、在 debugtalk.py 中定义的函数、环境变量和项目根目录等。 其中，debugtalk_py 属性表示 debugtalk.py 文件的内容， debugtalk_path 属性表示 debugtalk.py 文件的路径， dot_env_path 属性表示 .env 文件的路径， functions 属性表示在 debugtalk.py 中定义的函数，是一个字典， env 属性表示环境变量，是一个字典， RootDir 属性表示项目根目录，是一个字符串，表示 debugtalk.py 文件所在的目录。 &quot;&quot;&quot; debugtalk_py: Text = &quot;&quot; # debugtalk.py file content debugtalk_path: Text = &quot;&quot; # debugtalk.py file path dot_env_path: Text = &quot;&quot; # .env file path functions: FunctionsMapping = &#123;&#125; # functions defined in debugtalk.py env: Env = &#123;&#125; RootDir: Text = ( os.getcwd() ) # project root directory (ensure absolute), the path debugtalk.py located TestsMapping12345678class TestsMapping(BaseModel): &quot;&quot;&quot; 测试映射 1.project_meta 2.testcases 测试用例集，list下有多个用例 &quot;&quot;&quot; project_meta: ProjectMeta testcases: List[TestCase] TestCaseTime12345678910class TestCaseTime(BaseModel): &quot;&quot;&quot; 测试用例时间 1.start_at：开始时间默认为0 2.start_at_iso_format：以iso格式启动 3.duration：持续时间 &quot;&quot;&quot; start_at: float = 0 start_at_iso_format: Text = &quot;&quot; duration: float = 0 TestCaseInOut123456789class TestCaseInOut(BaseModel): &quot;&quot;&quot; 测试用例的输入输出： config_vars：配置变量 export_vars：导出变量 &quot;&quot;&quot; config_vars: VariablesMapping = &#123;&#125; export_vars: Dict = &#123;&#125; RequestStat12345678910class RequestStat(BaseModel): &quot;&quot;&quot; 请求指标： content_size：内容大小 response_time_ms：响应时间(ms) elapsed_ms：逝去的时间(ms) &quot;&quot;&quot; content_size: float = 0 response_time_ms: float = 0 elapsed_ms: float = 0 AddressData123456789101112class AddressData(BaseModel): &quot;&quot;&quot; 客户端与服务器地址数据 client_ip：客户端ip地址 client_port：客户端端口号 server_ip：服务器ip地址 server_port：服务器端口号 &quot;&quot;&quot; client_ip: Text = &quot;N/A&quot; client_port: int = 0 server_ip: Text = &quot;N/A&quot; server_port: int = 0 RequestData1234567891011121314class RequestData(BaseModel): &quot;&quot;&quot; 请求数据 method：请求方法，默认为GET url：url地址 headers：请求头 cookies：cookie信息 body：请求体 &quot;&quot;&quot; method: MethodEnum = MethodEnum.GET url: Url headers: Headers = &#123;&#125; cookies: Cookies = &#123;&#125; body: Union[Text, bytes, List, Dict, None] = &#123;&#125; ResponseData12345678910111213141516class ResponseData(BaseModel): &quot;&quot;&quot; 响应数据 status_code：状态码 headers：响应头 cookies：cookie信息 encoding：编码格式 content_type：内容类型 body：响应体 &quot;&quot;&quot; status_code: int headers: Dict cookies: Cookies encoding: Union[Text, None] = None content_type: Text body: Union[Text, bytes, List, Dict, None] ReqRespData12345678class ReqRespData(BaseModel): &quot;&quot;&quot; 请求响应数据 request：RequestData response：ResponseData &quot;&quot;&quot; request: RequestData response: ResponseData SessionData123456789101112131415161718class SessionData(BaseModel): &quot;&quot;&quot; request session data, including request, response, validators and stat data 它定义了一些属性，用于表示请求会话数据，包括请求、响应、验证器和统计数据等。 success 属性表示请求是否成功，是一个布尔值， req_resps 属性表示请求和响应数据，是一个 ReqRespData 类型的对象的列表， stat 属性表示请求统计数据，是一个 RequestStat 类型的对象， address 属性表示请求地址数据，是一个 AddressData 类型的对象， validators 属性表示验证器，是一个字典 &quot;&quot;&quot; success: bool = False # in most cases, req_resps only contains one request &amp; response # while when 30X redirect occurs, req_resps will contain multiple request &amp; response req_resps: List[ReqRespData] = [] stat: RequestStat = RequestStat() address: AddressData = AddressData() validators: Dict = &#123;&#125; StepResult1234567891011121314151617181920212223242526class StepResult(BaseModel): &quot;&quot;&quot; teststep data, each step maybe corresponding to one request or one testcase 它定义了一些属性，用于表示测试步骤的相关信息，包括测试步骤名称、测试步骤类型、请求会话数据、测试步骤执行时间、响应内容大小、导出变量和附件等。其中， name 属性表示测试步骤名称，是一个字符串， step_type 属性表示测试步骤类型，是一个字符串， success 属性表示测试步骤是否成功，是一个布尔值， data 属性表示请求会话数据，是一个 SessionData 类型的对象或 StepResult 类型的对象的列表， elapsed 属性表示测试步骤执行时间，是一个浮点数， content_size 属性表示响应内容大小，是一个浮点数， export_vars 属性表示导出变量，是一个字典， attachment 属性表示测试步骤的附件，是一个字符串。 &quot;&quot;&quot; name: Text = &quot;&quot; # teststep name step_type: Text = &quot;&quot; # teststep type, request or testcase success: bool = False data: Union[SessionData, List[&quot;StepResult&quot;]] = None elapsed: float = 0.0 # teststep elapsed time content_size: float = 0 # response content size export_vars: VariablesMapping = &#123;&#125; attachment: Text = &quot;&quot; # teststep attachmentStepResult.update_forward_refs() IStep123456789101112131415161718192021class IStep(object): &quot;&quot;&quot; 它定义了一些方法，用于表示测试步骤的相关信息，包括测试步骤名称、测试步骤类型、测试步骤结构和测试步骤执行等。 name 方法返回测试步骤名称，是一个字符串， type 方法返回测试步骤类型，是一个字符串， struct 方法返回测试步骤结构，是一个 TStep 类型的对象， run 方法用于执行测试步骤，接受一个 runner 参数，返回一个 StepResult 类型的对象。 &quot;&quot;&quot; def name(self) -&gt; str: raise NotImplementedError def type(self) -&gt; str: raise NotImplementedError def struct(self) -&gt; TStep: raise NotImplementedError def run(self, runner) -&gt; StepResult: # runner: HttpRunner raise NotImplementedError TestCaseSummary1234567891011class PlatformInfo(BaseModel): &quot;&quot;&quot; 平台信息 httprunner_version：httprunner版本号 python_version：python版本 platform：平台 &quot;&quot;&quot; httprunner_version: Text python_version: Text platform: Text PlatformInfo12345678910class PlatformInfo(BaseModel): &quot;&quot;&quot; 平台信息 httprunner_version：httprunner版本号 python_version：python版本 platform：平台 &quot;&quot;&quot; httprunner_version: Text python_version: Text platform: Text Stat12345678910class Stat(BaseModel): &quot;&quot;&quot; 统计信息 total：总数 success：成功的用例数 fail：失败的用例数 &quot;&quot;&quot; total: int = 0 success: int = 0 fail: int = 0 TestSuiteSummary12345678910111213141516class TestSuiteSummary(BaseModel): &quot;&quot;&quot; 测试套件结果 success：成功的状态 stat：统计信息 time：测试用例花费的时间 platform：平台信息 testcases：测试用例集 &quot;&quot;&quot; success: bool = False stat: Stat = Stat() time: TestCaseTime = TestCaseTime() platform: PlatformInfo testcases: List[TestCaseSummary]","categories":[{"name":"Httprunner","slug":"Httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Httprunner/"}],"tags":[{"name":"httprunner","slug":"httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Httprunner源码解读(1)源码模块内容","slug":"Httprunner源码解读-1-源码模块内容","date":"2023-06-10T03:12:13.000Z","updated":"2024-11-22T04:10:55.248Z","comments":true,"path":"2023/06/10/Httprunner源码解读-1-源码模块内容/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/06/10/Httprunner%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1-%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97%E5%86%85%E5%AE%B9/","excerpt":"前言由于团队要基于httprunner开展接口自动化测试，本人后续也想基于httprunner测试框架搭建一个API测试平台，而且目前很多开源的测试平台都是基于httprunner，所以，读懂源码必不可少","text":"前言由于团队要基于httprunner开展接口自动化测试，本人后续也想基于httprunner测试框架搭建一个API测试平台，而且目前很多开源的测试平台都是基于httprunner，所以，读懂源码必不可少 源码结构 builtin这个包做了一些内置的功能 123├── __init__.py├── comparators.py└── functions.py comparators：内置验证校验器 functions：内置的一些方法 database1└── engine.py 数据库模块是基于 DBEngine 实现的，用于对测试数据进行存储和管理。它支持多种类型数据库，如 MySQL、PostgreSQL、SQLite 等 engine.py实现了一个数据库引擎类DBEngine，用于连接数据库并执行SQL语句。在初始化时，它会根据传入的数据库URI创建一个SQLAlchemy的engine，并使用sessionmaker创建一个session。在执行SQL语句时，它会根据语句的类型（SELECT、UPDATE、DELETE、INSERT）返回不同的结果。如果是SELECT语句，它会根据size参数返回对应数量的结果，如果size为1，则返回一个字典，否则返回一个字典列表。在返回结果前，它会对结果进行处理，将datetime.datetime和datetime.date类型转换为字符串，将json字符串转换为字典。如果是UPDATE、DELETE、INSERT语句，则返回一个字典，包含受影响的行数。 ext123├── __init__.py└── uploader └── __init__.py 在httprunner基础上集成了别的插件 uploader：集成了上传文件的功能这是一个名为uploader的HTTPRunner扩展，它提供了上传文件的功能。如果要使用此扩展，需要先安装以下依赖项： requests_toolbelt filetype uploader扩展提供了prepare_upload_step函数，用于预处理上传测试步骤。它会将上传信息替换为MultipartEncoder对象。如果上传信息不存在，则不进行处理。MultipartEncoder对象是使用multipart_encoder函数初始化的，该函数接受上传字段作为参数，并返回一个初始化的MultipartEncoder对象。multipart_content_type函数用于准备请求头的Content-Type。如果依赖项未安装，则会引发ModuleNotFoundError异常。 thrift12├── data_convertor.py└── thrift_client.py thrift 模块是用于支持 Apache Thrift 的模块，可以将 thrift 服务定义文件（.thrift 文件）转换为 Python 代码，并生成可用的客户端和服务端代码。它基于 thrift 的 Python 库进行开发，支持多种类型的 thrift 服务，如 TCP、HTTP 等。 cli.py命令行驱动执行 client.py客户端相关方法,主要是封装 requests.Session.request,安全调用,输出log等, 给runner.py调用. compat.py提供各种处理兼容性的方法,包括让v2版本的用例能在v3版本继续运行的相关转换方法 config.py包含三个类：ConfigThrift、ConfigDB 和 Config。这些类的作用是为 HttpRunner 提供配置信息，包括 Thrift 协议相关的配置信息和数据库相关的配置信息。通过使用这些类，用户可以方便地设置和管理配置信息，从而更好地控制测试用例的执行过程。 exceptions.py定义了失败类型的异常信息 loader.py加载文件内容的方法 make.py主要集成参数使之生效在测试用例中，如config、request、teststep等等，构成一个可用的用例 models.py定义各种model类,以BaseModel为父类 parser.py各种解析方法，主要用于数值类型判断后自动转换 response.py处理响应报文格式 runner.py运行项目的核心 step.py文件定义了 Step 类，该类表示 HttpRunner 测试用例中的一个步骤，提供了多个属性和方法，用于获取步骤的信息和运行步骤 step_request.py用于运行 HttpRunner 测试步骤中的请求 step_sql_request.py定义了 run_step_sql_request 函数，该函数表示 HttpRunner 测试用例中的一个 SQL 查询步骤，提供了解析 SQL 查询请求、执行 SQL 查询、提取 SQL 查询结果、更新 step_variables 和验证 SQL 查询结果等功能。 step_testcase.py定义了 StepTestCase 类，该类表示 HttpRunner 测试用例中的一个测试步骤，继承自 Step 类，提供了多个属性和方法，用于获取测试步骤的信息和运行测试步骤 step_thrift_request.py定义了 run_step_thrift_request 函数，该函数表示 HttpRunner 测试用例中的一个 Thrift 请求步骤，提供了解析 Thrift 请求、执行 Thrift 请求、提取 Thrift 请求结果、更新 step_variables 和验证 Thrift 请求结果等功能。 utils.py一些工具函数用于处理数据、打印信息等,辅助测试用例的编写和执行，可以在测试用例中直接使用。","categories":[{"name":"Httprunner","slug":"Httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Httprunner/"}],"tags":[{"name":"httprunner","slug":"httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Git使用详细教程","slug":"Git使用详细教程","date":"2023-06-05T05:37:53.000Z","updated":"2023-06-17T03:26:10.342Z","comments":true,"path":"2023/06/05/Git使用详细教程/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/06/05/Git%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言现在大部分的开发团队都以 Git 作为自己的版本控制工具，需要对 Git 的使用非常的熟悉。这篇文章中本人整理了自己在工作过程中经常使用到的 Git 命令，方便在偶尔忘记时速查。","categories":[{"name":"Git","slug":"Git","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/git/"}]},{"title":"Jmeter压测-Linux运行Jmeter环境","slug":"Jmeter压测-Linux运行Jmeter环境","date":"2023-06-05T04:13:37.000Z","updated":"2024-11-22T04:11:16.298Z","comments":true,"path":"2023/06/05/Jmeter压测-Linux运行Jmeter环境/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/06/05/Jmeter%E5%8E%8B%E6%B5%8B-Linux%E8%BF%90%E8%A1%8CJmeter%E7%8E%AF%E5%A2%83/","excerpt":"前言使用jmeter做压测的时候，在windows上不太稳定，所有一直在linux服务器上使用jmeter做压力测试。本篇记录下linux上搭建jmeter环境，以及运行jmeter脚本，查看报告。","text":"前言使用jmeter做压测的时候，在windows上不太稳定，所有一直在linux服务器上使用jmeter做压力测试。本篇记录下linux上搭建jmeter环境，以及运行jmeter脚本，查看报告。 相关环境：java 1.8jmeter 5.5 一、java环境先在Linux上安装java环境，安装1.8.0版本，先查找java相关的列表 1yum -y list java* 安装java-1.8.0-openjdk相关的文件 1yum -y install java-1.8.0-openjdk* 安装完成后环境变量自动已经生效了，输入java -version查看版本号 1java -version 二、安装jmeter在jmeter官网https://jmeter.apache.org/下载jmeter的zip安装包,下载完成后传到linux上任意目录，比如我的是/root/jmeter。使用unzip命令解压zip文件，如果没有安装过unzip，先yum安装下 1yum -y install unzip 使用unzip 解压.zip 文件 1unzip apache-jmeter-5.5.zip 解压完成后，接下来vi编辑&#x2F;etc&#x2F;profile文件，设置环境变量,在文件底部编辑 1export PATH=/root/jmeter/apache-jmeter-5.5/bin/:$PATH 接下来source执行&#x2F;etc&#x2F;profile文件让环境变量生效 1source /etc/profile 输入jmeter -v能看到内容说明安装成功了 1jmeter -v 三、启动jmeter脚本测试脚本文件(Test Plan.jmx)导入linux服务器上,执行以下命令启动测试计划 1jmeter -n -t Test\\ Plan.jmx -l testplan.jtl 参数说明： n 表示以no gui方式运行测试计划 t 表示测试计划，后面跟测试计划名称, 有空格的话用\\空格表示 l表示测试结果，后面跟测试结果文件名称，后缀是.jtl文件 四、查看报告文件测试结束后导出testplan.jtl文件，在本地jmeter上查看运行结果","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/"}],"tags":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/Jmeter/"},{"name":"性能测试","slug":"性能测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Docker安装jenkins教程","slug":"Docker安装jenkins教程","date":"2023-06-01T06:22:12.000Z","updated":"2024-11-22T04:10:50.263Z","comments":true,"path":"2023/06/01/Docker安装jenkins教程/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/06/01/Docker%E5%AE%89%E8%A3%85jenkins%E6%95%99%E7%A8%8B/","excerpt":"一、jenkins安装1.查找，下载jenkins镜像文件 1docker search jenkins 下载Jenkins镜像文件 1docker pull jenkins/jenkins:lts","text":"一、jenkins安装1.查找，下载jenkins镜像文件 1docker search jenkins 下载Jenkins镜像文件 1docker pull jenkins/jenkins:lts 2.创建Jenkins挂载目录并授权权限，这样我们就可以很方便地对容器内的配置文件进行修改。 123mkdir -p /data/jenkins_home/chmod 777 /data/jenkins_home/ 3.创建并启动Jenkins容器 123456docker run -d --name jenkins \\ -p 8080:8080 -p 50000:50000 \\ -v /root/Yoga/data/jenkins_home:/var/jenkins_home \\ -e TZ=Asia/Shanghai \\ jenkins/jenkins:lts -d 后台运行镜像 -p 8080:8080 -p 50000:50000 表示将容器内部的 8080 和 50000 端口映射到主机的 8080 和 50000 端口 -v &#x2F;root&#x2F;Yoga&#x2F;data&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home &#x2F;var&#x2F;jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 &#x2F;data&#x2F;jenkins_home目录 -e TZ&#x3D;Asia&#x2F;Shanghai 表示设置时区为亚洲上海时区。 –name myjenkins 给容器起一个别名 4.查看jenkins是否启动成功，如下图出现端口号，就为启动成功了 1docker ps -l 5.查看docker容器日志 1docker logs jenkins 6.配置镜像加速，进入 cd &#x2F;data&#x2F;jenkins_home 目录 123修改hudson.model.UpdateCenter.xml里的内容将 url 修改为清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 7.访问Jenkins页面，输入你的ip加上8090 8.管理员密码获取方法，编辑initialAdminPassword文件查看，把密码输入登录中的密码即可，开始使用。 1cat /root/Yoga/data/jenkins_home/secrets/initialAdminPassword","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/Docker/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/jenkins/"}]},{"title":"Centos安装docker教程","slug":"Centos安装docker教程","date":"2023-05-31T09:46:14.000Z","updated":"2024-11-22T04:10:41.348Z","comments":true,"path":"2023/05/31/Centos安装docker教程/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/05/31/Centos%E5%AE%89%E8%A3%85docker%E6%95%99%E7%A8%8B/","excerpt":"一、安装前必读在安装 Docker 之前，先说一下配置，我这里是Centos7Linux 内核：官方建议 3.10 以上，3.8以上貌似也可。","text":"一、安装前必读在安装 Docker 之前，先说一下配置，我这里是Centos7Linux 内核：官方建议 3.10 以上，3.8以上貌似也可。 1.查看当前的内核版本 1uname -r 2.使用 root 权限更新 yum 包（生产环境中此步操作需慎重，看自己情况，学习的话随便搞） 1yum -y update 这个命令不是必须执行的，看个人情况，后面出现不兼容的情况的话就必须update了 注意 12yum -y update：升级所有包同时也升级软件和系统内核；yum -y upgrade：只升级所有包，不升级软件和系统内核 3.卸载旧版本（如果之前安装过的话） 1yum remove docker docker-common docker-selinux docker-engine 二、安装Docker的详细步骤1.安装需要的软件包， yum-util 提供yum-config-manager功能，另两个是devicemapper驱动依赖 1yum install -y yum-utils device-mapper-persistent-data lvm2 2.设置 yum 源 设置一个yum源，下面两个都可用 123yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库） 3.选择docker版本并安装（1）查看可用版本有哪些 1yum list docker-ce --showduplicates | sort -r （2）选择一个版本并安装：yum install docker-ce-版本号 1yum -y install docker-ce-18.06.0.ce-3.el7 4.启动 Docker 并设置开机自启 12systemctl start dockersystemctl enable docker","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/docker/"}]},{"title":"如何在 Django REST Framework 中使用 JWT 身份验证","slug":"如何在-Django-REST-Framework-中使用-JWT-身份验证","date":"2023-05-28T07:46:05.000Z","updated":"2024-11-22T04:10:32.160Z","comments":true,"path":"2023/05/28/如何在-Django-REST-Framework-中使用-JWT-身份验证/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/05/28/%E5%A6%82%E4%BD%95%E5%9C%A8-Django-REST-Framework-%E4%B8%AD%E4%BD%BF%E7%94%A8-JWT-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","excerpt":"JWT 代表JSON Web Token，它是客户端&#x2F;服务器应用程序使用的一种身份验证策略，其中客户端是使用 JavaScript 和一些前端框架（如 Angular、React 或 VueJS）的 Web 应用程序。","text":"JWT 代表JSON Web Token，它是客户端&#x2F;服务器应用程序使用的一种身份验证策略，其中客户端是使用 JavaScript 和一些前端框架（如 Angular、React 或 VueJS）的 Web 应用程序。 JWT 是如何工作的？JWT 只是一个授权令牌，应该包含在所有请求中： 1curl http://127.0.0.1:8000/hello/ -H &#x27;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQzODI4NDMxLCJqdGkiOiI3ZjU5OTdiNzE1MGQ0NjU3OWRjMmI0OTE2NzA5N2U3YiIsInVzZXJfaWQiOjF9.Ju70kdcaHKn1Qaz8H42zrOYk0Jx9kIckTn9Xx7vhikY&#x27; JWT 是通过将用户名+密码交换为访问令牌和刷新令牌来获取的。 访问令牌通常是短暂的（5 分钟左右过期，但可以自定义）。 刷新令牌的寿命稍长一些（24 小时后过期，也可自定义）。它类似于身份验证会话。过期后，您需要再次使用用户名+密码进行完整登录。 这是为什么？ 这是一项安全功能，也是因为 JWT 拥有更多信息。如果你仔细看我上面给出的例子，你会看到令牌由三部分组成： 1xxxxx.yyyyy.zzzzz 这些是构成 JWT 的三个独特部分： 1header.payload.signature 所以我们在这里： 123header = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9payload = eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQzODI4NDMxLCJqdGkiOiI3ZjU5OTdiNzE1MGQ0NjU3OWRjMmI0OTE2NzA5N2U3YiIsInVzZXJfaWQiOjF9signature = Ju70kdcaHKn1Qaz8H42zrOYk0Jx9kIckTn9Xx7vhikY 此信息使用 Base64 编码。如果我们解码，我们会看到这样的东西： 标头 1234&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125; 有效负载 123456&#123; &quot;token_type&quot;: &quot;access&quot;, &quot;exp&quot;: 1543828431, &quot;jti&quot;: &quot;7f5997b7150d46579dc2b49167097e7b&quot;, &quot;user_id&quot;: 1&#125; 签名 签名由 JWT 后端发出，使用 header base64 + payload base64 + SECRET_KEY。根据每个请求验证此签名。如果客户端更改了标头或有效负载中的任何信息，它将使签名无效。检查和验证签名的唯一方法是使用应用程序的 SECRET_KEY. 除此之外，这就是为什么您应该始终保守SECRET_KEY 秘密！ 安装与设置对于本教程，我们将使用djangorestframework_simplejwt DRF 开发人员推荐的库。 1pip install djangorestframework_simplejwt 设置.py 12345REST_FRAMEWORK = &#123; &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: [ &#x27;rest_framework_simplejwt.authentication.JWTAuthentication&#x27;, ],&#125; 网址.py 12345678from django.urls import pathfrom rest_framework_simplejwt import views as jwt_viewsurlpatterns = [ # Your URLs... path(&#x27;api/token/&#x27;, jwt_views.TokenObtainPairView.as_view(), name=&#x27;token_obtain_pair&#x27;), path(&#x27;api/token/refresh/&#x27;, jwt_views.TokenRefreshView.as_view(), name=&#x27;token_refresh&#x27;),] 示例代码对于本教程，我将使用以下路由和 API 视图： 视图.py 1234567891011from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.permissions import IsAuthenticatedclass HelloView(APIView): permission_classes = (IsAuthenticated,) def get(self, request): content = &#123;&#x27;message&#x27;: &#x27;Hello, World!&#x27;&#125; return Response(content) 网址.py 123456from django.urls import pathfrom myapi.core import viewsurlpatterns = [ path(&#x27;hello/&#x27;, views.HelloView.as_view(), name=&#x27;hello&#x27;),] 用法我将使用HTTPie通过终端使用 API 端点。但您也可以使用 cURL（在许多操作系统中都很容易使用）在本地进行尝试。 或者，通过访问端点 URL 来使用 DRF Web 界面，如下所示： 获取令牌第一步是验证并获取令牌。端点是/api/token/，它只接受POST请求。 1http post http://127.0.0.1:8000/api/token/ username=vitor password=123 所以基本上你的响应主体是两个标记： 1234&#123; &quot;access&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQ1MjI0MjU5LCJqdGkiOiIyYmQ1NjI3MmIzYjI0YjNmOGI1MjJlNThjMzdjMTdlMSIsInVzZXJfaWQiOjF9.D92tTuVi_YcNkJtiLGHtcn6tBcxLCBxz9FKD3qzhUg8&quot;, &quot;refresh&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTU0NTMxMDM1OSwianRpIjoiMjk2ZDc1ZDA3Nzc2NDE0ZjkxYjhiOTY4MzI4NGRmOTUiLCJ1c2VyX2lkIjoxfQ.rA-mnGRg71NEW_ga0sJoaMODS5ABjE5HnxJDb0F8xAo&quot;&#125; 之后，您将在客户端存储访问令牌和刷新令牌，通常在localStorage中。 为了访问后端受保护的视图（即需要身份验证的 API 端点），您应该在所有请求的标头中包含访问令牌，如下所示： 1http http://127.0.0.1:8000/hello/ &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQ1MjI0MjAwLCJqdGkiOiJlMGQxZDY2MjE5ODc0ZTY3OWY0NjM0ZWU2NTQ2YTIwMCIsInVzZXJfaWQiOjF9.9eHat3CvRQYnb5EdcgYFzUyMobXzxlAVh_IAgqyvzCE&quot; 您可以在接下来的五分钟内使用此访问令牌。 五分钟后，令牌将过期，如果您再次尝试访问该视图，您将收到以下错误： 1http http://127.0.0.1:8000/hello/ &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNTQ1MjI0MjAwLCJqdGkiOiJlMGQxZDY2MjE5ODc0ZTY3OWY0NjM0ZWU2NTQ2YTIwMCIsInVzZXJfaWQiOjF9.9eHat3CvRQYnb5EdcgYFzUyMobXzxlAVh_IAgqyvzCE&quot; 刷新令牌要获取新的访问令牌/api/token/refresh/，您应该使用发布 刷新令牌的刷新令牌端点： 1http post http://127.0.0.1:8000/api/token/refresh/ refresh=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTU0NTMwODIyMiwianRpIjoiNzAyOGFlNjc0ZTdjNDZlMDlmMzUwYjg3MjU1NGUxODQiLCJ1c2VyX2lkIjoxfQ.Md8AO3dDrQBvWYWeZsd_A1J39z6b6HEwWIUZ7ilOiPE 返回的是一个新的访问令牌，您应该在后续请求中使用它。 刷新令牌在接下来的 24 小时内有效。当它最终也过期时，用户将需要使用他们的用户名和密码再次执行完全身份验证以获得一组新的访问令牌+刷新令牌。 刷新令牌有什么意义？乍一看，刷新令牌可能看起来毫无意义，但实际上有必要确保用户仍然拥有正确的权限。如果您的访问令牌的过期时间很长，则更新与令牌关联的信息可能需要更长的时间。这是因为身份验证检查是通过密码学手段完成的，而不是查询数据库和验证数据。所以一些信息有点缓存。 还有一个安全方面，从某种意义上说，刷新令牌仅在 POST 数据中传输。并且 访问令牌是通过 HTTP 标头发送的，该标头可能会在传输过程中被记录下来。因此，如果您的访问令牌被泄露，这也会提供一个较短的窗口。","categories":[{"name":"后端","slug":"后端","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"后端/Django","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%90%8E%E7%AB%AF/Django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/django/"},{"name":"rest_framework","slug":"rest-framework","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/rest-framework/"}]},{"title":"Markdown常用语法介绍","slug":"Markdown常用语法介绍","date":"2023-05-27T04:25:22.000Z","updated":"2024-11-22T04:11:21.753Z","comments":true,"path":"2023/05/27/Markdown常用语法介绍/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/05/27/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"1、Markdown标题 —— 提升标题等级ctrl +1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题","text":"1、Markdown标题 —— 提升标题等级ctrl +1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2、Markdown字体 用1个星号*或底线_表示斜体 斜体：Ctrl+I 用2个星号*或底线_表示粗体 加粗：Ctrl+B 用3个星号*或底线_表示粗斜体1234567891011*斜体文字*_斜体文字_**粗体文字**__粗体文字__***粗斜体文字***___粗斜体文字___ 3、Markdown分割线123*********------ 4、Markdown删除线 —— 删除线：Alt+Shift+51~~tencent.com~~ 5、代码块 —— 代码：Ctrl+Shift+&#96;1`world` 6、Markdown下划线 —— 下划线：Ctrl+U1&lt;u&gt;带下划线文本&lt;/u&gt; 7、Markdown列表无序列表(三个都行） 1234567891011* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符。 1231. 第一项2. 第二项3. 第三项 8、Markdown嵌套列表1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 9、Markdown链接 —— 超链接：Ctrl+K12这是一个链接 [新浪新闻](https://news.sina.com.cn/)&lt;https://news.sina.com.cn/&gt; 10、Markdown图片 —— 图像：Ctrl+Shift+I12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 11、Markdown表格 —— ctrl + T 插入表格123456789| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 || 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 12、Markdown高亮 —— ctrl + T 插入表格1==高亮==","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/markdown/"}]},{"title":"如何进行技术面试（面试官视角）","slug":"如何进行技术面试（面试官视角）","date":"2023-02-28T03:49:29.000Z","updated":"2024-11-22T04:10:26.783Z","comments":true,"path":"2023/02/28/如何进行技术面试（面试官视角）/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/02/28/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9D%A2%E8%AF%95%E5%AE%98%E8%A7%86%E8%A7%92%EF%BC%89/","excerpt":"说起来在我第一次做面试官之前，并没有人教过我应该怎么做，我则一直将面试视作通过一小时左右的沟通，对候选人形成一个整体的印象，最后给出一个主观的评价的过程。在这么多次的面试中，我也总结出了一些经验可以和大家分享。","text":"说起来在我第一次做面试官之前，并没有人教过我应该怎么做，我则一直将面试视作通过一小时左右的沟通，对候选人形成一个整体的印象，最后给出一个主观的评价的过程。在这么多次的面试中，我也总结出了一些经验可以和大家分享。 验证简历真实性首先花一些时间聊一聊简历上提到的项目，请对方进一步介绍这个项目的业务、自己在其中承担的职责和遇到的问题。然后针对其中自己了解的部分提几个问题，如「据我所知这类项目的难点是某某方面，请问你是否有遇到、是如何解决的」，确认对方的项目经验是否真实、是否比较深度地参与了项目。 围绕简历提问尽量提问对方了解和擅长的话题，让对方有足够的表达机会，发挥出正常水平，考察候选人擅长的部分要比不擅长的部分更有价值。 开放性问题避免问有标准答案的问题，而是可以问「遇到某种情况时可能是什么原因、你会怎么做」或「请解释一下某个事物是如何工作的」这样开放性的问题，给对方足够的发挥空间、主动提到一些自己的知识和经验。 也许有些候选人不喜欢这样的问题，认为缺少安全感、不知道该说什么，但我觉得开放性问题才有足够的区分度，才能在短时间内对候选人形成立体的印象。我们可以在候选人实在不知道从何说起时，对问题再做进一步的解释和提示。 围绕话题由浅入深应该针对同一话题准备多个难度逐步增加的问题，让对方回答时思路能够相对流畅，更容易考察对方在这一话题上的深度；反过来应该避免大量零散、无联系、无难度区分的小问题。 没必要执着于答案有时在反复提示下对方的答案仍差那么一点，在面试时间大多比较紧张的情况下，我们没必要花更多的时间去让对方答出答案。在候选人表示无法准确回答问题时，也可以引导他做出一些合理的猜测（这时的重点在于猜测是否合理而不是是否正确）。只要候选人在这一问题上说足够多的话，我们就可以考察到其水平了，不一定要等他说出最后的答案。 自己不懂也没关系 在一开始，我会担心问出的问题我自己也不了解，对方回答之后会把自己问倒或者无法考察对方水平。但后来发现完全没有必要，因为面试官没有义务即时地对候选人的回答做出评价（告诉对方对还是错），即使对于不了解的话题，自己也可以从对方的自信程度、逻辑层面，对回答有一个大体的判断的。 现场编码可以很简单候选人在现场会非常紧张，面试时间也有限，在现场编码环节没必要出太难的题，重点在于考察候选人是否有最基本编程思维和编码能力。例如我觉得一些难度不高，但适合用递归解决的题目会比较合适，可以考虑在候选人编码的过程中一直保持沟通，注重过程而不是结果。 同时我反对为候选人在面试前或面试后布置编码的作业，这会让候选人付出不对等的时间去准备面试，也很容易从「考察候选人的能力」变成「考察候选人的诚意」。 重复使用一套题库没什么问题可以自己建立自己的面试题库，在一次次面试中对其进行反复地打磨，让问题更准确、考察更全面。有些话题可能是永远都不过时的，例如对于后端工程师可能是并发模型及与之相关的线程、内存等话题。 给对方提问的机会一般面试的最后一个步骤是让候选人提问，不要把这个过程敷衍掉，可以引导对方提问，告诉对方都可以问哪些问题。如可以补充一下没有提及的技术话题、可以问我司的技术架构或选型、可以问所面试的职位和如果入职之后所参与的项目、可以问日常工作环境和时间等。这样可以让对方有一个主动打开话题的机会，互相判断需求是否匹配，即使没有通过面试也让对方对公司有一个比较好的印象。 有任何顾虑都可以 pass 掉我们前面做了这么多都是为了让候选人有更好的面试体验、发挥出自己最好的水平。这种情况下如果仍对候选人某一方面的表现有顾虑的话，应该果断地拒绝掉，招进来一个不合适的人损失远比错过一个合适的人大。 沟通是否顺畅很重要沟通是后续开展一切工作的基础，如果觉得与候选人的沟通不顺畅，对方总是不能理解自己的意思，那么即使候选人的技术水平满足要求，也应该慎重考虑。 留下面试的记录我每次面试结束后都会尽快开始写对候选人的评价，大多在一两百字，先列出面试聊到的内容、觉得好和不好的地方、了解到的对方的技术栈，然后总结一下对候选人技术水平和沟通情况的评价。这样可以帮助自己整理思路，在候选人比较多的时候也不会记混，最后给出通过与否的评价，同时还能给下一轮的面试官提供参考。","categories":[{"name":"开发","slug":"开发","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"那些有趣的注释，有没有你曾用过的","slug":"那些有趣的注释，有没有你曾用过的","date":"2023-02-27T03:12:07.000Z","updated":"2024-11-22T04:10:21.245Z","comments":true,"path":"2023/02/27/那些有趣的注释，有没有你曾用过的/","link":"","permalink":"https://github.com/YoGazz/YoGazz.github.io/2023/02/27/%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%B3%A8%E9%87%8A%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%A0%E6%9B%BE%E7%94%A8%E8%BF%87%E7%9A%84/","excerpt":"闲来无事收集了一些有趣的注释，各式各样的都有，程序员真是一群有趣的人，喜欢哪一款拿走不谢","text":"闲来无事收集了一些有趣的注释，各式各样的都有，程序员真是一群有趣的人，喜欢哪一款拿走不谢 第一款：佛祖保佑，永无BUG 123456789101112131415161718192021// _ooOoo_ // o8888888o // 88&quot; . &quot;88 // (| -_- |) // O\\ = /O // ____/`---&#x27;\\____ // . &#x27; \\\\| |// `. // / \\\\||| : |||// \\ // / _||||| -:- |||||- \\ // | | \\\\\\ - /// | | // | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | // \\ .-\\__ `-` ___/-. / // ___`. .&#x27; /--.--\\ `. . __ // .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. // | | : `- \\`.;`\\ _ /`;.`/ - ` : | | // \\ \\ `-. \\_ __\\ /__ _/ .-` / / // ======`-.____`-.___\\_____/___.-`____.-&#x27;====== // `=---=&#x27; // // ............................................. // 佛祖保佑 永无BUG 第二款：神兽护体，永无BUG 1234567891011121314151617// ┏┓ ┏┓// ┏┛┻━━━┛┻┓// ┃ ┃ // ┃ ━ ┃// ┃ ┳┛ ┗┳ ┃// ┃ ┃// ┃ ┻ ┃// ┃ ┃// ┗━┓ ┏━┛// ┃ ┃ Code is far away from bug with the animal protecting // ┃ ┃ 神兽保护，永无BUG！// ┃ ┗━━━┓// ┃ ┣┓// ┃ ┏┛// ┗┓┓┏━┳┓┏┛// ┃┫┫ ┃┫┫// ┗┻┛ ┗┻┛ 1234567891011121314151617181920212223/** * ┏┓ ┏┓+ + * ┏┛┻━━━┛┻┓ + + * ┃ ┃ * ┃ ━ ┃ ++ + + + * ████━████ ┃+ * ┃ ┃ + * ┃ ┻ ┃ * ┃ ┃ + + * ┗━┓ ┏━┛ * ┃ ┃ * ┃ ┃ + + + + * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,永无bug * ┃ ┃ * ┃ ┃ + * ┃ ┗━━━┓ + + * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ + + + + * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛+ + + + */ 第三款：来首程序员打油诗，笑 123456789101112/** * 江城子 . 程序员之歌 * * 十年生死两茫茫，写程序，到天亮。 * 千行代码，Bug何处藏。 * 纵使上线又怎样，朝令改，夕断肠。 * * 领导每天新想法，天天改，日日忙。 * 相顾无言，惟有泪千行。 * 每晚灯火阑珊处，夜难寐，加班狂。*/ 12345678910/** * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */ 第四款：单身狗专用 123456789101112131415161718192021222324252627282930313233343536&lt;!-- :: :;J7, :, ::;7: ,ivYi, , ;LLLFS: :iv7Yi :7ri;j5PL ,:ivYLvr ,ivrrirrY2X, :;r@Wwz.7r: :ivu@kexianli. :iL7::,:::iiirii:ii;::::,,irvF7rvvLujL7ur ri::,:,::i:iiiiiii:i:irrv177JX7rYXqZEkvv17 ;i:, , ::::iirrririi:i:::iiir2XXvii;L8OGJr71i :,, ,,: ,::ir@mingyi.irii:i:::j1jri7ZBOS7ivv, ,::, ::rv77iiiriii:iii:i::,rvLq@huhao.Li ,, ,, ,:ir7ir::,:::i;ir:::i:i::rSGGYri712: ::: ,v7r:: ::rrv77:, ,, ,:i7rrii:::::, ir7ri7Lri , 2OBBOi,iiir;r:: ,irriiii::,, ,iv7Luur: ,, i78MBBi,:,:::,:, :7FSL: ,iriii:::i::,,:rLqXv:: : iuMMP: :,:::,:ii;2GY7OBB0viiii:i:iii:i:::iJqL;:: , ::::i ,,,,, ::LuBBu BBBBBErii:i:i:i:i:i:i:r77ii , : , ,,:::rruBZ1MBBqi, :,,,:::,::::::iiriri: , ,,,,::::i: @arqiao. ,:,, ,:::ii;i7: :, rjujLYLi ,,:::::,:::::::::,, ,:i,:,,,,,::i:iii :: BBBBBBBBB0, ,,::: , ,:::::: , ,,,, ,,::::::: i, , ,8BMMBBBBBBi ,,:,, ,,, , , , , , :,::ii::i:: : iZMOMOMBBM2::::::::::,,,, ,,,,,,:,,,::::i:irr:i:::, i ,,:;u0MBMOG1L:::i:::::: ,,,::, ,,, ::::::i:i:iirii:i:i: : ,iuUuuXUkFu7i:iii:i:::, :,:,: ::::::::i:i:::::iirr7iiri:: : :rk@Yizero.i:::::, ,:ii:::::::i:::::i::,::::iirrriiiri::, : 5BMBBBBBBSr:,::rv2kuii:::iii::,:i:,, , ,,:,:i@petermu., , :r50EZ8MBBBBGOBBBZP7::::i::,:::::,: :,:,::i;rrririiii:: :jujYY7LS0ujJL7r::,::i::,::::::::::::::iirirrrrrrr:ii: ,: :@kevensun.:,:,,,::::i:i:::::,,::::::iir;ii;7v77;ii;i, ,,, ,,:,::::::i:iiiii:i::::,, ::::iiiir@xingjief.r;7:i, , , ,,,:,,::::::::iiiiiiiiii:,:,:::::::::iiir;ri7vL77rrirri:: :,, , ::::::::i:::i:::i:i::,,,,,:,::i:i:::iir;@Secbone.ii:::--&gt; 第五款：骷髅头 12345678910111213141516171819202122232425/** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&quot; &quot;-. | * * | / \\ | * * | _ | | _ | * * | ( \\ |, .-. .-. ,| / ) | * * | &gt; &quot;=._ | )(__/ \\__)( | _.=&quot; &lt; | * * | (_/&quot;=._&quot;=._ |/ /\\ \\| _.=&quot;_.=&quot;\\_) | * * | &quot;=._&quot;(_ ^^ _)&quot;_.=&quot; | * * | &quot;=\\__|IIIIII|__/=&quot; | * * | _.=&quot;| \\IIIIII/ |&quot;=._ | * * | _ _.=&quot;_.=&quot;\\ /&quot;=._&quot;=._ _ | * * | ( \\_.=&quot;_.=&quot; `--------` &quot;=._&quot;=._/ ) | * * | &gt; _.=&quot; &quot;=._ &lt; | * * | (_/ \\_) | * * | | * * &#x27;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#x27; * * * * LASCIATE OGNI SPERANZA, VOI CH&#x27;ENTRATE * ************************************************************** */ 第六款：标准键盘 12345678910111213141516/** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &#x27;│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 第七款：顶 123456789101112131415/** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 */ 还有一些其他有趣搞怪的注释 12345678910111213141516171819202122/** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ___/`---&#x27;\\____ * . &#x27; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | | * \\ .-\\__ `-` ___/-. / * ___`. .&#x27; /--.--\\ `. . __ * .&quot;&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#x27;====== * `=---=&#x27; * ............................................. * 佛曰：bug泛滥，我已瘫痪！ */ 123456789101112131415161718192021222324252627282930313233/** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * */ 上面这些都不能满足你，想要找更多的ascii图在这里http://www.asciiworld.com/","categories":[{"name":"后端","slug":"后端","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/java/"},{"name":"测试","slug":"测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Httprunner","slug":"Httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Httprunner/"},{"name":"Git","slug":"Git","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/"},{"name":"Docker","slug":"Linux/Docker","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/Linux/Docker/"},{"name":"后端","slug":"后端","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Django","slug":"后端/Django","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%90%8E%E7%AB%AF/Django/"},{"name":"其他","slug":"其他","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"开发","slug":"开发","permalink":"https://github.com/YoGazz/YoGazz.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"功能测试","slug":"功能测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"工作方法","slug":"工作方法","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"效率","slug":"效率","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%95%88%E7%8E%87/"},{"name":"数据迁移","slug":"数据迁移","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"},{"name":"httprunner","slug":"httprunner","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/httprunner/"},{"name":"接口自动化","slug":"接口自动化","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"git","slug":"git","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/git/"},{"name":"Jmeter","slug":"Jmeter","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/Jmeter/"},{"name":"性能测试","slug":"性能测试","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"jenkins","slug":"jenkins","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/jenkins/"},{"name":"docker","slug":"docker","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/docker/"},{"name":"django","slug":"django","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/django/"},{"name":"rest_framework","slug":"rest-framework","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/rest-framework/"},{"name":"markdown","slug":"markdown","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/markdown/"},{"name":"面试","slug":"面试","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"程序员","slug":"程序员","permalink":"https://github.com/YoGazz/YoGazz.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}